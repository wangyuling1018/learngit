笔记：
      1. 继承最最基本的特点:
          (1) 子类对象 内部包含 基类(子)对象
           (2) 子类内部 可以访问 基类的 非私有(公有/保护)成员(变量/函数)

      2. 公有继承独有的特点：
          （1）只有在公有继承下，子类对象在类的外部 可以访问 基类的公有成员，其他继承不可以
          （2）只有在公有继承下，子类类型的指针 和 基类类型的指针 可以进行转换
                                                子类类型的引用 和 基类类型的引用 可以进行转换
                                                其他继承方式不可以。

          Human* ph = &s; // 子类类型指针 可以 隐式转换为  基类类型指针
          Human& rh = s;   // 子类类型引用 可以 隐式转换为 基类类型引用

          // 以上两行代码，编译器认为访问范围缩小，是安全的.(向上造型)


      3. 关于指针的一个原理的探讨
         指针为什么需要类型?  答：指针的类型决定了指针的 眼界(*) 和 步长(+1)
             int a;   double b;   short c;  char d;

             int* pa;            *pa            pa+1
             double* pb;        *pb            pb+1
             short* pc;          *pc            pc+1
             char* pd;          *pd            pd+1
    眼界：例如站在int类型的指针上，放眼望去，只能看到4个字节那么远。眼界是用解引用（*）的时候可以拿的多少字节的数据，例如*pa可以拿4个字节的数据。

    步长：体现的是+1，移动多少个字节。例如pa+1后pa移动4个字节。


类型转换操作符  cast.cpp
    若源类型是基本类型，目标类型是类类型，则只能
        - 通过类型转换构造函数实现自定义类型转换
            class 目标类型{
                目标类型(const 源类型& src) { ... }
            };
    若目标类型是基本类型，源类型是类类型，则只能
        - 通过类型转换操作符函数实现自定义类型转换
            class 源类型{
                operator 目标类型(void) const { ... }
            };
 
    自定义类型转换 cast2.cpp
        - 若源类型和目标类型都是类类型(而非基本类型)，则既可以通过类型转换构造函数也可以通过类型转换操作符函数实现自定义类型转换,但不要两者同时使用
        - 若源类型和目标类型都是基本类型，则无法实现自定义类型转换，基本类型间的类型转换规则完全由编译器内置

操作符重载的限制
    不是所有的操作符都能重载，以下操作符不能重载
        - 作用域限定操作符(::)
        - 直接成员访问操作符(.)
        - 条件操作符(?:)
        - 字节长度操作符(sizeof)
        - 类型信息操作符(typeid)
    无法重载所有操作数均为基本类型的操作符
        - 1+1=8?

继承

继承的基本概念和语法
    - 共性与个性
    - 抽取共性与保留个性
    - 基类与子类
    - 继承与派生
    - 继承的语法
        class 子类:继承方式1 基类1,继承方式2 基类2,...{
            ...
        };
    - 继承方式
        - 公有继承: public
        - 保护继承: protected
        - 私有继承: private

三种继承方式相同的基本特点
继承的基本特点 derived.cpp
    继承所要达到的目的:
        - 子类对象包含基类子对象
        - 子类内部可以直接访问基类的所有非私有成员
    继承的本质:
        - 基类的非私有成员在子类中仅仅为可见，而非拥有
    注意:
        - 对于继承切忌不要理解为基类的成员变为子类的成员,继承不会改变类成员的作用域，基类的成员永远都是基类的成员，并不会因为继承而变成子类的成员
        
继承的基本特点  hide.cpp
    尽管基类的公有和保护成员在子类中直接可见，但仍然可以在子类中重新定义这些名字，子类中的名字会隐藏所有基类中的同名定义
    如果需要在子类内部访问一个在基类中定义却被子类标识符所隐藏的名字，可以借助作用域限定操作符"::" 实现
    因为作用域的不同，分别在子类和基类中定义的同名成员函数(包括静态成员函数)，并不构成重载关系，相反是一种隐藏关系.
    任何时候，在子类的内部，总可以通过作用域限定操作符“::”，显式地调用那些在基类中定义却被子类所隐藏的成员
    //“因为作用域的不同”的意思：基类和子类各自有各自的作用域。
    //重载关系的作用域是相同的，所以永远不会构成重载关系。


三种继承方式的差别
    基类中的公有、保护和私有成员，在子类中将对这些基类成员的访问控制限定进行重新标记
        基类中的    在公有子类中标记为    在保护子类中标记为    在私有子类中标记为
        公有成员       公有成员                 保护成员           私有成员
        保护成员       保护成员                 保护成员           私有成员
        私有成员       私有成员                 私有成员           私有成员
    当“通过”子类访问其所继承的基类的成员时，需要考虑因继承方式对访问控制限定的影响
        public/protected.cpp / private.cpp


公有继承的基本特点  phs.cpp
    子类对象在类外可以访问基类公有成员(其他继承方式不可以)
        - 如果被子类同名标识符隐藏也可以借助作用域限定符“”指定访问基类的公有成员
    子类类型的指针或引用和基类类型的指针或引用可以进行转换(其他继承方式不可以)
    子类类型的指针或者引用能隐式转换为基类类型
        class Human { ... . };
        class Student : public Human { ... };
        Student student ;
        Human* phuman = &student;
        Human& rhuman = student;
        - 编译器认为访问范围缩小是安全的
            hs.cpp
    基类类型的指针或者引用不能隐式转换为子类类型
        class Human {...};
        class Student : public Human { ...
        Human human;
        Student* pstudent =
        static_cast<Student*>(&human);
        Student& rstudent =
        static cast<Student&>(human);
        - 编译器认为访问范围扩大是危险的
            hs.cpp
    编译器对类型安全的检测仅仅基于指针或引用本身
        - class Human {... };
          class Student: public Human {... };
          Student student (...);
          Human* phuman = &student;
          Human&' rhuman = student;
          Student* pstudent =
          static_cast<Student*> (phuman);
          Student& rstudent =
          static_cast<Student&> (rhuman);
        - 基类指针或引用的实际目标，究竟是不是子类对象，完全由程序员自己判断


子类的构造、析构
子类的构造  CCons.cpp
    子类没有定义构造函数
        - 编译器为子类提供的默认无参构造函数
          定义基类子对象，并调用其基类的无参构造函数,构造该子类对象中的基类子对象。
    子类定义构造函数但没有在初始化表中指明基类部分构造方式
        - 定义基类子对象,并调用其基类的无参构造函数，构造该子类对象中的基类子对象。
    子类定义构造函数并在初始化表中指明基类部分构造方式
        - 定义基类子对象并调用指明的其基类的构造函数。
    子类对象的构造过程
        - 构造基类子对象->构造成员变量->执行构造代码
    阻断继承
        - 子类的构造函数无论如何都会调用基类的构造函数，构造子类对象中的基类子对象
        - 如果把基类的构造函数定义为私有，那么该类的子类就永远无法被实例化为对象
        - 在C++中可以用这种方法阻断一个类被扩展
 
子类的析构
    子类没有定义析构函数
        - 编译器将提供一个默认析构函数
          析构完所有的成员变量以后，会自动调用其基类的析构函数.
    子类定义析构函数
        - 子类的析构函数在执行完自身析构代码，并析构完所有的成员变量以后，会自动调用其基类的析构函数.
    子类对象的析构过程
        - 执行析构代码->析构成员变量->析构基类子对象

子类的拷贝构造
    子类没有定义拷贝构造函数
        - 编译器为子类提供的默认拷贝构造函数
          定义基类子对象，并调用其基类的拷贝构造函数,构造该子类对象中的基类子对象
    子类定义了拷贝构造函数，但没有在初始化表指明其基类部分的构造方式
        - 定义基类子对象，并调用其基类的无参构造函数,构造该子类对象中的基类子对象
    子类定义了拷贝构造函数，同时初始化表中指明了其基类部分以拷贝方式构造
        - 定义基类子类对象，并调用其基类的拷贝构造函数，构造该子类对象中的基类子对象

子类的拷贝赋值
    子类没有定义拷贝赋值函数
        - 编译器为子类提供的缺省拷贝赋值函数，会自动调用其基类的拷贝赋值函数，复制该子类对象中的基类子对象
    子类定义了拷贝赋值函数，但没有显式调用其基类的拷贝赋值函数
        - 子类对象中的基类子对象将得不到复制
    子类定义了拷贝赋值函数，同时显式调用了其基类的拷贝赋值函数
        - 子类对象中的基类子对象将得到复制
