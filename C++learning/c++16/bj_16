
C++异常处理
异常处理语法
    抛出异常    throw.cpp
        throw 异常对象;
        一 可以抛出基本类型的对象，如:
            throw -1;
            throw "内存分配失败!";
        一 也可以抛出类类型的对象，如:
            MemoryException ex;
            throw ex;
            throw MemoryException ();
        - 但不要抛出局部对象的指针，如:
            MemoryException ex;
            throw &ex;//错误!
    捕获异常    throw.cpp
        try {
            可能引发异常的语句; }
        catch (异常类型1& ex) {
            针对异常类型1的异常处理; }
        catch (异常类型2& ex) {
            针对异常类型2的异常处理; }
        ...
        catch (...) {
            针对其它异常类型的异常处理; }
    未抛出异常时的流程
    生异常时的流程
    捕获异常    throw2.cpp
        - 建议在catch子句中使用引用接收异常对象，避免因为拷贝构造带来性能损失
        - 推荐以匿名临时对象的形式抛出异常
        -异常对象必须允许被拷贝构造和析构
    匹配顺序    throw3.cpp
        -根据异常对象的类型自上至下顺序匹配，而非最优匹配，因此对子类类型异常的捕获不要放在对基类类型异常的捕获后面

异常说明    except.cpp
    异常说明是函数原型的一部分，旨在说明函数可能抛出的异常类型
        - 返回类型 函数名(形参表) throw(异常类型1,异常类型2,..){函数体; }
    异常说明是一种承诺，承诺函数不会抛出异常说明以外的异常类型
        - 如果函数抛出了异常说明以外的异常类型，那么该异常将无法被捕获，并导致进程中止
        - std::unexpected()->std::terminate()->abort()
        隐式抛出异常的函数也可以列出它的异常说明
    异常说明可以没有也可以为空   except2.cpp
        - 没有异常说明，表示可能抛出任何类型的异常void foo (void) {...}
        - 异常说明为空，表示不会抛出任何类型的异常void foo(void) throw(){ ...)
    异常说明是虚函数覆盖的条件之一
        - 如果基类版本带有基本类型异常说明，那么覆盖版本必须一致，但如果基类版本带有类类型异常说明，那么覆盖版本可以带有子类类型异常说明。
    异常说明在函数的声明和定义中必须保持严格一致否则将导致编译错误


异常处理模式
    抛出基本类型的异常，根据异常对象的值分别处理
    抛出类类型的异常，根据异常对象的类型分别处理
    利用类类型的异常，携带更多诊断信息，以便查错
    可以在catch块中继续抛出所捕获的异常，或其它异常
    任何未被捕获的异常，都会由std::unexpected()函数处理，缺省的处理方式就是中止进程
    忽略异常，不做处理

构造函数中的异常    consexcept.cpp
    构造函数可以抛出异常，某些时候还必须抛出异常
        - 构造过程中可能遇到各种错误，比如内存分配失败
        - 构造函数没有返回值，无法通过返回值通知调用者
    构造函数抛出异常，对象将被不完整构造，而一个被不完整构造的对象，其析构函数永远不会被执行
        - 所有对象形式的成员变量，在抛出异常的瞬间，都能得到正确地析构(构造函数的回滚机制)
        - 所有动态分配的资源，必须在抛出异常之前，自己手动释放，否则将形成资源的泄漏。

析构函数中的异常
    不要从析构函数中主动抛出异常  desconexcept.cpp
        - 在两种情况下，析构函数会被调用
            √正常销毁对象，离开作用域或显式delete
            √在异常传递的堆栈辗转开解(stack-unwinding)过程中
        - 对于第二种情况，异常正处于激活状态，而析构函数又抛出了异常，这时C++将通过std::terminate()函数，令进程中止
    对于可能引发异常的操作，尽量在析构函数内部消化
        -try { ...} catch(..) {...}


标准库异常
    #include <stdexcept>
    bad_alloc
    bad_cast
    bad_type_id
    bad_exception

