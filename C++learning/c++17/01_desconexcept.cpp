//
//  01_desconexcept.cpp
//  C++learning
//
//  Created by 王育玲 on 2023/2/25.
//

/*析构函数中的异常
 不要从析构函数中主动抛出异常：
 1.在两种情况下，析构函数会被调用
    正常销毁对象，离开作用域或显示delete
    在异常传递的堆栈辗转开解（stack-unwinding）过程中
 2.对于第二种情况，异常正处于激活状态，而析构函数又抛出了异常，这是C++将通过std::terminate()函数，令进程中止
 3.对于可能引发异常的操作，尽量在析构函数内部消化
    try{...} catch(...){...}
 */

//堆栈辗转开解（stack-unwinding）:2个异常不能同时用一个catch，不能捕获到异常，会被系统杀死。
//在C++中只允许在一个异常还没被捕获到的情况下，另外一个异常不能出现，如果出现就会被系统杀死
//如果析构不抛出异常，就不会出现2个异常同时出现。
//解决方法：析构函数中的异常，在析构函数内存捕获（try..catch）

#if 0

#include <iostream>
using namespace std;
//不要在析构函数中“主动”抛出异常

void foo(){
    throw "foo函数中抛出的异常";
}

void bar(){
    throw "bar函数中抛出的异常";
}

class A{
public:
    ~A(){
       // throw "析构函数中抛出的异常"; //在析构函数中“主动”抛出异常
       // bar();  //在析构函数中“隐式”抛出异常
        try{
            bar();
        }
        catch(const char* e){
            cout << "析构函数中捕获异常信息:" << e << endl;
        }
    }
};



// 以上的代码模拟类的设计者(例如:类库、别人设计的类、自己设计的类)
// --------------------------------------
// 以下的代码模拟类的使用者
int main( void ) {
    try{
        A a;
        foo();
        //....后续代码...
    }//（1）a.~A()  （2）释放a本身所占内存空间
    catch(const char* e){
        cout << "main中捕获异常信息:" << e << endl;
    }

    return 0;
}

#endif
/*
 C++标准库设计的异常类 #include <stdexcept>
 1.exception、runtime_error、logic_error 是抽象类，不能定义对象，因为里面有纯虚函数，主要为以下子类继承一些东西
 2.子类,C++建议抛以下的类对象：
    verflow_error :一般上溢异常的时候抛这个对象，例如：栈容器，一直压栈，栈满了用户还在压栈，可以抛出这个对象给用户，用户一捕获发现栈满了
    underflow_error：一般下溢异常的时候抛这个对象，例如：栈容器，一直弹栈，栈空了用户还在弹栈，可以抛出这个对象给用户，用户一捕获发现栈空了
    invalid_argument：无效参数，例如：设计了一个函数参数范围，如果用户传入的参数不对，可以抛出这个异常
    length_error：长度错误。例如：一般函数传入数组了，还要把数组个数传进去，如果个数传错就是长度错误，或者叫超出范围，引起访问越界
    out_of_range：超出范围
 
 
    void foo(int* p,int size){ ...}
    int a[30];
    foo(a,50);//长队错误，超出范围，引起访问越界
 
 
 
 
 
 
 
 
 
 */
