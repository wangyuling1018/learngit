笔记：
    1. 任何 基本类型的数据 都可以 隐式转换（编译器帮我们转换）为 布尔类型
       任何 复合类型的数据 如何转换为布尔类型????????????( 第17次会讲到 )

    2. 自定义转换？？？？？？？（第8次课会讲到）

    3. C++换名机制
       C++国际标准规定，所有C++函数都必须换名。全天下的C++编译器都必须遵守(都换名) , 但是换名规则都不一样
      
       int  sum( int a, int b ) {....}
      
       g++ :  _Z3sumii
       cl.exe : ?sumYAHHH@Z


C++复合类型
结构、联合和枚举
    C++的结构  type.cpp
        -定义结构型的变量时，可以省略struct关键字
        -可以定义成员函数，在结构体中的成员函数内部可以直接访问本结构体的成员，无需通过“.”或“->"
    C++的联合  type.cpp
        -定义联合型的变量时，可以省略union关键字
        -支持匿名联合
    C++的枚举  type.cpp
        -定义枚举型的变量时，可以省略enum关键字
        一独立的类型，和整型之间不能隐式转换.

布尔类型
    表示布尔量的数据类型  type.cpp
        -bool
    布尔类型的字面值常量
        -true表示真
        -false表示假
    布尔类型的本质
        -单字节整数，用1和0表示真和假.
    任何基本类型都可以被隐式转换为布尔类型
        -非O即真，0即假

函数关系--重载
重载
    重载关系 overload.cpp
        -同一作用域内，函数名相同， 参数表不同
        -根据实参类型和形参的类型进行匹配，调用最匹配的函数
        -只有同一作用域内的同名函数才涉及重载的关系，不同作用域的同名函数涉及的是隐藏关系。 overload2.cpp
    重载解析 overload3.cpp
        一完全匹配>常量转换>升级转换>标准转换>自定义转换>省略号匹配
    函数指针的类型决定其调用的重载函数的版本


重载的本质
    重载是通过C++换名机制来实现的   overload.cpp
    通过extern "C”可以要求C++编译器按照C方式编译函数， 即不做换名，当然也就无法重载。
    范例代码:extern

哑元函数
哑元
    只指定形参类型而不指定形参名称的函数，谓之哑元
        -保证函数的向下兼容
        -形成函数的重载版本
    范例代码:forover.cpp


缺省(默认)参数
缺省参数
    可以为函数的形参指定缺省(默认)值，当调用该函数时若未指定实参，则使用形参的缺省(默认)值。
    如果函数的某一个形参具有缺省(默认)值，那么该形参后面的所有形参必须都具有缺省(默认)值
    尽量避免因为使用缺省参数而导致重载匹配歧义
    函数形参的缺省(默认)值只能在函数声明中指定
    范例代码:defparam.cpp
