//
//  03_alias.cpp
//  C++learning
//
//  Created by 王育玲 on 2023/2/25.
//
//之前讲的引用都是左值引用，因为98、03标准中，只有引用的说法，没有右值引用
//c++11标准有了右值引用，98、03标准中的引用都是左值引用。

/*
 左值引用和右值引用的差别：
 1.左值引用是别名，是外号 //左值本来就有真名，再给起一个外号
 2.右值引用就是真名。//右值本来就没有真名，是匿名内存，所以可以起一个真名。可以修改。
 */

/*
 左值和右值：
 1.可以“取”地址的值就是左值，左值通常具名
 2.不可“取”地址的值就是右值，右值通常匿名
 
 左值 可以细分为：非常左值（无const修饰），常左值（有const修饰），一般都叫 lvalue
 右值 可以细分为：纯右值（rvalue），将亡值（xvalue）
 纯右值：一块无名内存中，存的是基本类型的数据。
 将亡值：一块无名内存中，存的是类类型的数据。
 其实右值都是将亡值。
 例如： 10；是纯右值，  Human(22，“张飞”);是将亡值
 
 左值引用是一个小麻花 &
 右值引用是二个小麻花 &&

 */

#if 0
// 左值引用/右值引用 和 左值/右值 的关系
#include <iostream>
using namespace std;

int foo(){
    int m = 100;
    return m;
}
//以上代码模块库
//..............................
//以下代码模拟用户
int main(void){
    // 函数的生命期
    // 具名内存-->能够取址-->左值|非常左值(无const修饰)
    //                           |常左值  (有const修饰)
    
    //左值又分为2种：非常左值（无const修饰），常左值（const修饰）
    int a = 10;
    int& ra = a;//ok，引用
    const int& cra = a;//ok，引用更加严格，可以
    
    const int b = 20;
    //int& rb = b;//error，引用更加宽松，不可以
    const int& rb = b;//ok，引用
    
    // 语句级生命期(引用可以延长右值的生命期)
    // 匿名内存-->不能取址-->右值|直接更改右值毫无意义(98/03标准给出的结论)
    //                           |C++11标准认为 给了真名就可以改
    
    //直接更改右值毫无意义,是98/03标准给出的结论，右值的声明周期很短，过了分号就死。语句级生命期。
    //右值只能用常引用作为别名
    //引用可以延长右值的生命周期
    //引用可以作为左值(非常左值、常左值)、右值的引用，所以常引用是万能引用
    10;
    const int& ri = 10;//ok，加const修饰为了保持和本体一致，本体（右值）不让修改，直接更改右值毫无意义,是98/03标准给出的结论，加const修饰通过别名也不能修改，就可以编译通过了 //常引用
    //别名ri的生命周期是main的生命周期了，那么10的生命周期也就延长了
    
    int&& rri = 10;//C++11标准认为 给了真名就可以改，不用保持和本体一致
    
    //函数的返回值也是匿名内存
    /*|返回值100的内存|*/foo(); //(1)分配一块内存空间 （2）生成跳转指令
    //int& fi = foo();//error，函数返回值不让修改，通过别名又可以修改了，会报错
    const int& fi = /*|100|*/foo();//ok，加const修饰，通过别名也不能修改，就可以编译通过了 //常引用
    //别名fi的生命周期是main的生命周期了，那么函数foo()的生命周期也就延长了
    
    int&& ffi = /*|100|*/foo();//C++11标准认为 给了真名就可以改，不用保持和本体一致
    
    return 0;
}
#endif


