
纯虚函数
纯虚函数、抽象类
    纯虚函数    abstract.cpp
        - 形如
         class 类名{
            virtual 返回类型 函数名(形参表)= 0;
         };
         的虚函数，称为纯虚函数或抽象方法
    抽象类
        - 拥有纯虚函数的类称为抽象类
        - 抽象类不能实例化为对象
        - 抽象类的子类如果不对基类中的全部纯虚函数提供有效的覆盖，那么该子类就也是抽象类
    纯抽象类
        - 全部由纯虚函数构成的抽象类称为纯抽象类或接口

虚函数的应用
运行时类型信息(RTTI)
    动态类型转换(dynamic_cast) dynamiccast.cpp
        - 用于将基类类型的指针或引用转换为其子类类型的指针或引用，前提是子类必须从基类多态继承(即基类包含至少一个虚函数)
        - 动态类型转换会对所需转换的基类指针或引用做检查，如果其目标确实为期望得到的子类类型的对象，则转换成功，否则转换失败。
        - 针对指针的动态类型转换，以返回空指针(NULL)表示失败，针对引用的动态类型转换，以抛出bad_cast异常表示失败。
    typeid操作符   typeinfo.cpp
        - #include < typeinfo>
        - 返回type_ info类型对象的常引用
            type_ info类的成员函数name() ,返回类型名字符串
            type_ info类妓持"==" 和"!=" 操作符,可直接用于类型相同与否的判断
        - 当其作用于基类类型的指针或引|用的目标对象时
            若基类不包含虚函数typeid所返回类型信息由该指针或用本身的类型决定
            若基类包含至少一一个虚函数即存在多态继承，typeid所返回类型信息由该指针或用的实际目标对象的类型决定

虚析构函数
虚析构   delbd.cpp
    delete一个基类指针(指向子类对象）
        - 实际被调用的仅仅是基类的析构函数
        - 基类的析构函数只负责析构子类对象中的基类子对象
        - 基类的析构函数不会调用子类的析构函数
        - 在子类中分配的资源将形成内存泄漏
        - 如果将基类的析构函数声明为虚函数,那么实际被调用的将是子类的析构函数
        - 子类的析构函数将首先释放子类对象自己的成员,然后再调用基类的析构函数释放该子类对象的基类部分,最终实现完美的资源释放
    空虚析构函数
        - 没有分配任何动态资源的类,无需定义析构函数
        - 没有定义析构函数的类,编译器会为其提供一一个缺省析构函数,但缺省析构函数并不是虚函数
        - 为了保证delete- -个指向子 对象的基类指针时,能够正确调用子类的析构函数，就必须把基类的析构函数定义为虚函数,即使它是一一个空函数
        - 任何时候, 为基类定义- -个虚析构函数总是无害的
    一个类中,除了构造函数和静态成员函数外,任何函数都可以被声明为虚函数

异常前导
错误与错误处理
    何为错误?
        语法错误:程序员在编码阶段解决并通过编译
        逻辑错误:程序员借助于调试工具诊断并修改
        功能错误:程序员修改代码，测试员回归验证
        设计缺陷:设计员修改设计，程序员重新编码
        需求不符:分析员修改需求，设计员调整设计
        环境异常:客服协助用户调整程序的运行环境
        操作不当:客服指导用户按照正确的方法操作
    错误处理主要针对在实际运行环境中发生，却在设人计、编码和测试阶段无法预料的，各种潜在的异常
    三种典型的错误处理机制
        - 通过返回值返回错误信息 return.cpp
            √所有局部对象都能正确地被析构
            √逐层判断，流程繁琐
        - 借助setjmp/longjmp远程跳转
            √一步到位，流程简单
            √某些局部对象可能因此丧失被析构的机会
        - 抛出- 捕获异常对象
            √形式上一步到位，流程简单
            √实际上逐层析构局部对象，避免内存泄漏
