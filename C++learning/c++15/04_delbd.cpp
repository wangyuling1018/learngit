//
//  04_delbd.cpp
//  C++learning
//
//  Created by 王育玲 on 2023/2/19.
//
/*
 delete一个基类指针（指向子类对象）
 1.实际被调用的仅仅是基类的析构函数
 2.基类的析构函数只负责析构子类对象中的基类子对象
 3.基类的析构函数不会调用子类的析构函数
 4.在子类中分配的资源将形成内存泄漏
 5.如果将基类的析构函数声明为虚函数，那么实际被调用的将是子类的析构函数
 6.子类中析构函数将首先释放子类对象自己的成员，然后再调用基类的析构函数释放该子类对象的基类部分，最终完美的资源释放
 */

/*
 空的虚析构函数：
 1.没有分配任何动态资源的类，无需定义析构函数
 2.没有定义析构函数的类，编译器会为其提供一个缺省析构函数，但缺省析构函数并不是虚函数
 3.为了保证delete一个指向子类对象的基类指针时，能够正确调用子类的析构函数，就必须把基类的析构函数定义为虚函数，即使它是一个空函数。
 4，任何时候，为基类定义一个虚析构函数总是无害的
 */

/*一个类中，除了构造函数和静态成员函数外，任何函数都可以声明为虚函数
   因为构造函数是造对象的，对象还没造出来呢，不能说构造也调子类的构造？？
   因为静态成员函数调用 不需要 指针调用，直接类调用了，多态必须是指针调用
*/

#if 0

// 虚析构函数 - delete一个基类类型指针(指向子类对象),能够保证调用子类的析构函数
#include <iostream>
using namespace std;
class A{
public:
    A(): m_a(new int){
        //【int* m_a = new int;】定义m_a,初值为指向一块堆内存(动态资源)
        cout << "A() is invoked ---申请了一块堆内存:" << m_a << endl;
    }
   virtual ~A() {
        delete m_a;
        cout << "~A() is invoked ---释放了一块堆内存:" << m_a << endl;
       // 释放 m_a 本身所占内存空间
    }
private:
    int* m_a;
};

class B : public A{
public:
    B() : m_b(new int){
        //【A();】定义 基类子对象,利用 基类子对象.A()
        //【int* m_b = new int;】定义m_b,初值为指向一块堆内存(动态资源)
        cout << "B() is invoked ---申请了一块堆内存:" << m_b << endl;
    }
    ~B(){
        delete m_b;
        cout << "~B() is invoked ---释放了一块堆内存:" << m_b << endl;
        // 对于 基类子对象,利用 基类子对象.~A()
        // 释放 m_b/基类子对象 本身所占内存空间
    }
private:
    int* m_b;
};



//以上代码模块库
//..............................
//以下代码模拟用户
int main(void){
    //B* p = new B;// 定义 B类堆对象,利用 B类对象.B()
    //delete p; //利用 p->析构函数(~B())   释放B类堆对象本身所占内存空间
    
    A* p = new B;// 定义 B类堆对象,利用 B类对象.B()
    delete p;
    //基类的析构函数不是虚函数时，利用 p->虚析构函数(~A())   释放B类堆对象本身所占内存空间。//如果没有有虚函数，根据p指针的本身类型来调用析构函数
    
    //基类的析构函数是虚函数时，利用 p->虚析构函数(~B())   释放B类堆对象本身所占内存空间。//如果有虚函数了，根据p指针的指向类型来调用析构函数
    
    return 0;
}

#endif

