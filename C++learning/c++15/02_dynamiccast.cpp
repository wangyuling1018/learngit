//
//  02_dynamiccast.cpp
//  C++learning
//
//  Created by 王育玲 on 2023/2/19.
//

//虚函数不止玩多态一个应用，还有其他应用（动态类型转换等）

// 动态类型转换 : 基类类型指针 转换为 子类类型指针
//                基类类型引用 转换为 子类类型引用

/*运行时类型信息（RTTI）
 动态类型转换：
 1.用于将基类类型的指针或引用转换为其子类类型的指针或引用
 2.前提是子类必须从基类多态继承（即基类包含至少一个虚函数）
 3.动态类型转换会对所需转换的基类指针或引用做检查，如果其指向的对象的类型与所要转换的目录类型一致，则转换成功，否则转换失败
 4.针对指针的动态类型转换，以返回空指针（NULL）表示失败，针对引用的动态类型转换，以抛出bade_cast异常表示失败
 */

/*
 只要基类中有虚函数，玩的就是多态继承
 只要类中有虚函数，编译器就会根据这个类的信息 制作一张虚函数表
 当基类有虚函数，基类、以及所有子类、孙子类都有虚函数表
 动态类型转换 就是通过虚函数表 来检查是否转换成功的
 虚函数表中 包含 类的名字、类的版本、类的大小、虚函数地址等等信息
 静态转换是编译器转，在编译的时候转，动态转换是程序运行期间做转换
 */


#if 0

#include <iostream>
using namespace std;
class A { // 编译器根据A类信息,将制作一张虚函数表    "A"...|A::foo的地址
    virtual void foo() {}
};
class B : public A { // 编译器根据B类信息,将制作一张虚函数表   "B"...|A::foo的地址
};
class C : public B { // 编译器根据C类信息,将制作一张虚函数包   "C"...|A::foo的地址
};
class D { // 编译器根据D类信息,不会制作虚函数表
};
// 以上的代码模拟类的设计者(例如:类库、别人设计的类、自己设计的类)
// --------------------------------------
// 以下的代码模拟类的使用者
int main( void ) {
    B b; // |虚表指针|-->编译器根据B类信息制作的虚函数表
    
    A* pa = &b; // B*-->A*(子类类型指针-->基类类型指针)编译器可以隐式转换  //pa指向b对象

    cout << "----------dynamic_cast----------" << endl;
    B* pb = dynamic_cast<B*>(pa);//又合理，又安全 // pa-->b对象所占内存空间-->虚表指针-->编译器根据B类信息制作的虚函数表-->"B"
    cout << "A* pa--->B* pb: " << pb << endl;
    //动态类型转换的时候，编译器会检查 你想将基类型指针pa 转换成 B类型指针，编译器看看pa指向的是不是B类型指针，如果是B类型指针则成功，否则失败
    
    C* pc = dynamic_cast<C*>(pa);//不安全，转出来pc是空指针，没有转换成功 // pa-->b对象所占内存空间-->虚表指针-->编译器根据B类信息制作的虚函数表-->"B"
    cout << "A* pa--->C* pc: " << pc << endl;
    
    D* pd = dynamic_cast<D*>(pa);//不合理，转出来pd是空指针，没有转换成功 // pa-->b对象所占内存空间-->虚表指针-->编译器根据B类信息制作的虚函数表-->"B"
    cout << "A* pa--->D* pd: " << pd << endl;
    
    cout << "----------static_cast----------" << endl;
    pb = static_cast<B*>(pa); // A*-->B* 的反向 B*-->A*可以隐式
    cout << "A* pa--->B* pb: " << pb << endl;
    pc = static_cast<C*>(pa); // A*-->C* 的反向 C*-->A*可以隐式
    cout << "A* pa--->C* pc: " << pc << endl;
 //   pd = static_cast<D*>(pa); // A*--->D* 的反向 D*-->A*不可以隐式
 //   cout << "A* pa--->D* pd: " << pd << endl;
    return 0;
}

#endif






