笔记：
    1. 多态需要具备的条件：
        （1）基类必须有虚函数，子类必须提供覆盖版本
        （2）必须利用 基类类型指针(必须指向子类对象) 调用 虚函数
                必须利用 基类类型引用(必须引用子类对象) 调用 虚函数

       多态的结果：
             最终 调用的为 子类覆盖版本的虚函数，而非基类原始版本的虚函数

钻石继承
钻石继承问题
    - 一个子类继承自多个基类，而这些基类又源自共同的祖先，这样的继承结构称为钻石继承(菱形继承)
    - 公共基类子对象，在汇聚子类对象中，存在多个实例    diamond.cpp
    - 在汇聚子类内部，或通过汇聚子类对象，访问公共基类的成员，会因继承路径的不同而导致匹配歧义


虚继承
    钻石继承问题解决方法  virtualinherit.cpp
        - 在继承表中使用virtual关键字
        - 虚继承可以保证
            (1) 公共虚基类子对象在汇聚子类对象中仅存一份实例
            (2) 公共虚基类子对象被多个中间子类子对象所共享
            
虚继承实现原理
    - 汇聚子类对象中的每个中间子类子对象都持有一个指针，
      通过该指针可以获取中间子类子对象的首地址到公共虚基类子对象的首地址的偏移量


虚函数
非虚的世界  selfconst.cpp
    对象的自恰性
        - 对同样的函数调用，各个类的对象都会做出恰当的响应
    通过基类类型指针调用普通成员函数只能调用基类的成员函数
        - 即便这个基类类型的指针指向子类对象,调用的也为基类的成员函数。
        - 一旦调用子类所特有的成员函数， 将引发编译错误。
        - 编译器仅根据指针的类型确定调用哪个类的普通成员函数

虚函数和覆盖
虚函数   bdv.cpp
    - 形如
        class 类名{
            virtual 返回类型 函数名(形参表){...}
        };
        的成员函数，称为虚函数或方法
覆盖
    - 如果子类的成员函数和基类的虚函数具有相同的函数签名，那么该成员函数就也是虚函数，无论其是否带有virtual关键字，且与基类的虚函数构成覆盖关系



虚函数的世界  bdv.cpp
    通过基类类型指针调用虚函数
        - 如果基类型指针指向基类对象，调用基类的原始版本虚函数。
        - 如果基类型指针指向子类对象，调用子类的覆盖版本虚函数。

虚函数应用-多态
多态  bdv.cpp
    - 如果子类提供了对基类虚函数的有效覆盖，那么通过一个基类型指针(指向子类对象)，或者基类型引用(引用子类对象)，
      调用该虚函数，实际被调用的将是子类中的覆盖版本，而非基类中的原始版本，这种现象称为多态。
    - 多态的重要意义在于，一般情况下，调用哪个类的成员函数是由指针或引用本身的类型决定的，而当多态发生时，调用哪个
      类的成员函数是由指针或引用的实际目标对象的类型决定的。

多态的条件
    - 需要在基类中定义虚函数，子类提供覆盖版本
    - 必须借助基类型指针(指向子类对象)或者基类型引用(引用子类对象)调用该虚函数
    具备上述两个要件，多态才能表现出来。

this指针和多态   this.cpp
    调用虚函数的指针也可以是基类中的this指针，同样能满足多态的条件，但在构造和析构函数中除外


多态揭秘-虚函数表
    虚函数表  vftable.cpp
    
虚函数表与动态绑定
    动态绑定
        - 当编译器看到通过指针或引用调用虚函数的语句时,
         并不急于生成有关函数调用的指令，相反它会用一段代码替代该语句，这段代码在运行时才能被执行，完成如下操作:
            1.确定指针或引用的目标对象所占内存空间
            2.从目标对象所占内存空间中找到虚表指针
            3.利用虚表指针找到虚函数表
            4.从虚函数表中获取所调用虚函数的入口地址
            5.根据入口地址，调用该函数
    动态绑定对性能的影响
        - 虚函数表本身会增加进程内存空间的开销
        - 与普通函数调用相比，虚函数调用要多出几个步骤,会增加运行时间的开销
        - 动态绑定会妨碍编译器通过内联来优化代码
        - 只有在确实需要多态特性的场合才使用虚函数，否则尽量使用普通函数
