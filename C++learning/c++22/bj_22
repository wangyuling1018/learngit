
类模板
    类模板的声明
        ●形式:
            template<class 类型形参1,....> class 类模板名{...};
            例如:
                template<class A, class B>class CMath{
                public:
                        A m_a;
                        B func() {....};
                };


    类模板的声明
        ●如果在类模板外实现成员函数
            template<class 类型形参1，.
            返回值类型 类模板名<类型形参1，...>.:函数名(调用形参1，....){ 函数体实现;}
            例如:template<class A,class B>B CMath<A,B>::func(){
                ....;
                }

    类模板的使用
        ●使用类模板必须对类模板进行实例化(产生真正的类)
            类模板本身并不代表一个确定的类型(即不能用于定义对象)，只有通过类型实参实例化成真正的类后才具备类的语义(即可以定义对象)。
            例如: CMath< int,double> math;
        ●类模板被实例化时类模板中的成员函数并没有实例化， 成员函数只有在被调用时才会被实例化(即产生真正成员函数)注意: 成员虚函数除外
        ●某些类型 虽然并没有提供类模板所需要的全部功能但照样可以实例化类模板,只. 要不调用那些未提供功能的成员函数即可。

    类模板的静态成员
        ●类模板中的静态成员即不是每个对象拥有-份
        ●也不是类模板拥有一份.
        ●而应该是由类模板实例化出的每一个真正的类各有-份.
        ●且为该实例化类定义的所有对象共享。

    类模板的递归实例化
        ●可以使用任何类型来实例化类模板。
        ●由类模板实例化产生的类也可以用来实例化类模板自身,这种做法称之为类模板的递归实例化。
        ●通过这种方法可以构建空间上具有递归特性的数据结构(例如:多维数组)。


类模板扩展
    全局特化
        ●全类特化:特化一个类模板可以特化该类模板所有的成员函数，相当于重新写了一个针对某种特定数据类型的具体类。
            声明形式:template<>class 类模板名<类型参数1....>{....};
            例如:template<>class CMath<char*>{....};
        ●成员特化:类模板特化除了可以对整个类进行特化以外，可以只针对某部分成员函数进行特化。
            声明形式:
            template < >
            返回值类型类模板名<类型参数1...> :成员函数名(调用参数1，....){.....}
            例如: template<> char *const CMath <char *const>::sum(...){....}
    局部特化
        ●类模板的局部特化,除非必要否则尽量不要特化，因为特化版本过多容易引发编译器匹配歧义。
    类型形参的缺省值
        ●类模板的类型形参可以带缺省值。
            实例化类模板时，如果提供了类型实参则用所提供的类型实参来实例化类模板，如果没有提供类型实参则用相应的类型形参的缺省类型来实例化类模板。
        ●如果类模板的某个类型形参带有缺省值，那么它后面的类型形参都必须带缺省值。
    数值形式的模板参数
        ●类模板的模板形参并不限于类型参数，普通数值也可以作为模板的参数。
        //模板形参就是类型参数的意思，数值形式：只能是整型作为模板参数

