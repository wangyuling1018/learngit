笔记：
    1. 异常处理？？？？？？？（第16次课会讲到）
          try {
              new int[0xFFFFFFFF];
          }
          catch( ... ) {
          }

    2. 左值 和  右值
       左值：能够取地址  &
       右值：不能取地址

    3. 常引用 和 常指针
       常引用 即 万能引用（可以 引用 非常左值、常左值、右值）
             int a = 10;
             const int& cra = a; // 但是 如果 常引用 引用的是 非常左值，通过别名将丧失修改目标内存的权限
       常指针 即 万能指针 （可以 指向 非常左值、常左值、右值）
             int a = 10;
             const int* pra = &a; // 但是 如果 常指针 指向的是 非常左值，通过常指针将丧失修改目标内存的权限

内联函数
    调用普通函数的问题:
        每个普通函数调用语句都需要发生跳转操作，这种跳转操作会带来时间开销。范例: inline.cpp
    内联就是用函数已被编译好的二进制代码，替换对该函数的调用指令
    内联在保证函数特性的同时，避免了函数调用的时间开销   //函数最基本的特性就是跳转
    范例:inline.cpp

内联函数总结
    内联会使可执行文件的体积和进程代码的内存变大,因此只有频繁调用的简单函数才适合内联
    inline关键字仅表示期望该函数被优化为内联，但是否适合内联则完全由编译器决定
    稀少被调用的复杂函数和递归函数都不适合内联

动态内存分配  new.cpp
    可以继续使用标准C库函数malloc/free
    更建议使用new/delete操作符在堆中分配/释放内存
        - int* pi=new int;
          delete pi;
    在分配内存的同时初始化
        - int* pi = new int (100);
    以数组方式new的也要以数组方式delete
        - int* pi = new int [4] {10, 20, 30, 40};
          delete[] pi;
          4｜10| 20| 30 40
    通过new操作符分配N维数组，返回N-1维数组指针
        - int (*prow)[4] = new int [3][4];
        - int (*ppage)[4][5] = new int[3][4][5];
    不能通过delete操作符释放已释放过的内存
    delete野指针后果未定义，delete空指针安全
    new操作符申请内存失败，将抛出异常

引用
    引用即内存的别名   alias.cpp
        - int a = 10;
          int& b = a;   //如果&的前面什么也没有，&的作用是取地址；如果&前面有类型，则&的作用是引用
    引用本身不占内存，并非实体，对引用的所有操作都是在对目标内存进行操作
    引用必须初始化，且不能更换目标
        - int c = 20;
          b = c;//仅仅是在对引用的目标内存进行赋值
    不存在引用的引用  alias.cpp
        - int a = 10;
          int& b = a;
          int& d = b;
    引用的常属性须和目标的常属性“一致”
        - const int e = 10;
        int& f = e;//ERROR
        const int& g = e;//OK
    可以限定更加严格
        - int a = 10;
         const int&h=a;//OK
    引用可以延长右值的生命周期  alias2.cpp
    常引用即万能引用
    引用的生命周期不能长于目标

