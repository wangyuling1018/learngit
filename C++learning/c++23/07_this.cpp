//
//  07_this.cpp
//  C++learning
//
//  Created by 王育玲 on 2023/3/3.
//
/*子模板访问基模板
 问题：
    在子类模板中访问基类模板的成员，编译器第一次编译时只在子类模板和全局中搜索使用的标识符号，不会到基类模板中搜索。
 解决方法：
    在子类模板中可以通过使用 作用域限定符 或 显示使用this指针。
 
 */

//子模板实例化出来的子类 和 基模板实例化出来的基类 之间的继承关系问题
//继承关系 发生在类之间，不是类模板之间
//子模板 和 基模板 实例化后 才会有继承关系

/*
 继承的基本特点：
 1.尽管基类的公有和保护成员在子类中直接可见，但仍然可以在子类中重新定义这些名字，子类中的名字会隐藏所有基类中的同名定义
 2.如果需要在子类内部访问一个基类中定义却被子类标识符所隐藏的名字，可以借助作用域限定操作符“：：”实现
 */

#if 0
#include <iostream>
using namespace std;
//子类模板访问基类模板

//基类模板
template<typename T>class Base{
public:
    void foo(){
        cout << "Base<T>::foo()" << endl;
    }
    int m_i;
};
//2.全局域
// int m_i;
// void foo(){}

//子类模板
template<typename T,typename D>class Derived:public Base<T>{
public:
    void bar(){
       // m_i = 100; //error，第一次编译error，子模板内 和 全局域 内无法找到
       // foo(); //error，第一次编译error，子模板内 和 全局域 内无法找到
        
        //解决方案：1.添加类名限定 ===>是为了变成 未知类型调用，第一次编译器不检查未知类型调用，第二次编译检查时 已经实例化了，有了继承关系了，子类可以访问基类的公有成员了。
        Base<T>::m_i = 100;
        //Base<T>::foo();
        
        //解决方案：2.显示使用this ===>是为了变成 未知类型调用，第一次编译器不检查未知类型调用，第二次编译检查时 已经实例化了，有了继承关系了，子类可以访问基类的公有成员了。
        //this->m_i;
        this->foo();
        
        //1.子模板内
       // int m_i;
       // void foo(){}
        
    }
};
int main(){
    Derived<int, double> d;
    d.bar();
}
#endif
