模板技巧        //模板技巧：特殊的模板型成员
    ●模板型成员变量
        成员变量，但其类型是由一个类模板实例化的未知类,那么它才可以称之为模板型成员变量。
        例如: template <class T> class Arrary{..};
             template <class D> class Sum{
             public:
                    Arrary<D> m_s; /模板型成员变量
             };
             //注意：类型参数不要写一样的，T 和 D，不要都写T
    ●模板型成员函数
        类模板的成员函数模板。
        例如:
            template <class T> class CMath{
            public:
                template <class D> void foo().....} //成员函数模板
            };
        如果在类外实现:
            template <class T>template<class D>void CMath<T>::foo(){....}

    ●模板型成员类型
        类模板中嵌套的类模板
            例如:
            template<class X>class A{
            public:
                template<class Y>class B{....};//模板型成员类型
            };
    ●模板型模板参数
        类模板的模板形参也可以是类模板，可以有缺省值。
            例如:
            template <class T> class Arrary{...};
            template< template <class D> class C=Arrary > class Sum{
                ......
            };


模板典型错误
    嵌套依赖
        ●问题:
            由于模板要经过两次编译，在第一次编译模板的代码时，类型形参的具体类型尚不明确，编译器将把类型形参的嵌套类型理解为
            某个未知类型的静态成员变量，因此编译器看到使用这样的标识符声明变量时会报告错误，这就叫嵌套依赖。
        ●解决方法:
            在类型形参的前面增加一个typename标识符，意在告诉编译器其后是一个类模板的嵌套使用。

    依赖模板参数访问成员函数模板
        ●问题:
            利用未知类定义的对象来访问成员函数模板时，编译器在第一次编译时无法解析成员函数模板的类型参数列表的<>而报告编译错误。
        ●解决方法:
            在成员函数模板之前增加template关键字，意在告诉编译器其后是一个函数模板实例，编译器就可以正确理解<>了。
    子模板访问基模板
        ●问题:
            在子类模板中访问基类模板的成员，编译器第-次编译时只在子类模板和全局域中搜索使用的标识符号，不会到基类模板中搜索.  //没有继承关系，只会找自己的和全局的
        ●解决方法:
            在子类模板中可以通过使用作用域限定符或显式使用this指针。
        //模板没有继承关系，模板实例化出来的类，才具有继承关系
    零值初始化
        ●问题:
            基本类型不存在缺省构造函数，未被初始化的局部变量都具有一个不确定的值(int a;//值不确定)
            类类型由于存在缺省构造函数，在未被初始化的情况下可以有一个确定的缺省初始化状态。(Integer a;//值确定)
            基于以上两点，就会在模板实现中产生不一致的语法语义。
        ●解决方法:
            如果希望模板中，所有类型参数的变量，无论是类类型还是基本类型都以缺省方式获得初始化，就必须对其进行显式的缺省构造T()。

    类模板中的成员虚函数
        ●类模板中的普通成员函数可以是虚函数
            即可以为类定义成员虚函数，和普通类的成员虚函数一样，类模板的成员虚函数也可以表现出多态性。
        ●类模板中的成员函数模板不可以是虚函数
            根据成员虚函数的多态机制，需要一个虚函数表(表中保存成员虚函数的入口地址)，而这个表是编译器在实例化类模板时就产生，
            类的成员函数模板的实例化(即产生真正的函数实体)需要编译器处理完调用后才会完成，这时才出现成员虚函数的地址。
        ●总结:
            成员函数模板的延迟编译 阻碍了虚函数表的静态构建。

