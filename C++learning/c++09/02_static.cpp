//
//  02_static.cpp
//  C++learning
//
//  Created by 王育玲 on 2023/2/19.
//

#if 0
//普通（非静态）成员变量：属于对象，对象的生命周期
//静态成员变量：不属于对象，进程级生命期
//进程级生命期的意思：程序一启动它就在

/*静态成员变量属于类，而不属于对象：
 1.静态成员变量不包含在对象中，进程级生命周期
 2.静态成员变量的定义和初始化，只能在类外部而不能在构造函数中进行
 3.静态成员变量依然受类作用域和访问控制限定符的约束
 4.访问静态成员变量，既可以通过类也可以通过对象
 5.静态成员变量为该类的所有对象实例所共享
 */

#include <iostream>
using namespace std;
class A {
public:
    A( ) {
        //【int m_i;】定义m_i //定义意味着分内存
        //静态成员变量不能在构造函数中定义，只能在全局中定义
    }
    int m_i; // 声明 //声明不意味着分内存
    static int m_si; // 声明 //声明不意味着分内存 //静态成员变量不是包子馅
};
int A::m_si = 0; // 全局域中定义并初始化 --> 进程级生命期

// 以上的代码模拟类的设计者(例如:类库、别人设计的类、自己设计的类)
// --------------------------------------
// 以下的代码模拟类的使用者
int main( void ) {
    A a, b; // 静态成员变量没有保存在对象中-->静态成员变量不属于对象
    cout << "a对象的大小: " << sizeof(a) << endl;//4字节大小，只包括了m_i的大小，说明m_si不属于对象a
    cout << "b对象的大小: " << sizeof(b) << endl;//4字节大小，只包括了m_i的大小，说明m_si不属于对象b

    A::m_si = 100; // 受到类作用域的约束，也受到访问控制限定符的约束 -->属于类

    a.m_si = 8888; // 当编译器发现利用对象访问的是静态成员变量，编译器会更改书写方式，a.m_si = 8888; 改成 A::m_si = 8888;
    cout << "b.m_si=" << b.m_si << endl; // 编译器将b.m_si改成A::m_si
    // 类的静态成员变量 被该类所有对象共享
    
    return 0;
}

#endif




