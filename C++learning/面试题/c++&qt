对C++11 的智能指针了解多少，可以自己实现一个智能指针吗？
    智能指针的本质就是一个类对象，并且其维护指针型成员变量
    常规指针的缺点
        - 当一个常规指针离开它的作用域时，只有该指针变量本身所占据的内存空间(通常是4个字节)会被释放，而它所指向的动态内存并未得到释放
        - 必须自己手动释放
    智能指针的优点
        - 智能指针是一个类对象(封装了常规指针)，当它离开作用域时，其析构函数负责释放该常规指针所指向的动态内存
    智能指针与常规指针的一致性
        - 为了使智能指针也能象常规指针一样，通过“*”操作符解引用，通过"->"操作符访问其目标的成员，就需要对这两个操作符进行重载

类型强转
    显式类型转换  convert.cpp
        C风格的显式类型转换
            -(目标类型)源类型变量
        C++风格的显式类型转换
            -目标类型(源类型变量)
        静态类型转换                                  //应用场景最广泛：指针、引用、其他变量等
            - static_cast< 目标类型> (源类型变量)
            - 隐式类型转换的逆转换
            - 自定义类型转换
        动态类型转换                                  //应用：指针、引用
            - dynamic_cast< 目标类型> (源类型变量)
            - 多态父子类指针或引用之间的转换
        常类型转换                                   //应用：指针、引用
            - const_cast< 目标类型> (源类型变量)
            - 去除指针或引用上的const属性
        重解释类型转换                                 //应用：指针、引用、指针和整型之间
            - reinterpret_cast< 目标类型> (源类型变量)
            - 任意类型的指针之间的转换或引用之间的转换
            - 任意类型的指针和整型之间的转换
        //能用静态类型转换 、动态类型转换、常类型转换就用这3种类型转换，不能用前3种类型转换，才用重解释类型转换
        //静态类型转换 、动态类型转换、常类型转换、重解释类型转换，都是c++温和的类型转换

数组结构和链表结构
    数组结构
        优点:随机访问方便，速度快效率高。
        缺点:插入删除不方便,效率低(内存空间分布的限制)
    链表结构
        优点:插入删除操作方便，效率高。
        缺点:随机访问不方便效率低，往往就是通过在遍历过程中对给定的条件进行检测。
    总结:STL模板库中所提供的容器类,结合了数组和链表的优缺点，使用户从诸如内存管理的细节中得以解脱(对数组和链表的操作进行了封装)

常用容器概述
    vector：向量，连续存储，可随机访问。
    deque：双向队列，连续存储，随机访问。
    list：链表，内存不连续，不支持随机访问。
    stack：栈，不可随机访问，只允许再开头增加/删除元素。
    queue：单向队列，尾部增加，开头删除。
    set：集合，采用红黑树实现，可随机访问。查找、插入、删除时间复杂度为O(logn)。
    map：图，采用红黑树实现，可随机访问。查找、插入、删除时间复杂度为O(logn)。
    hash_set：哈希表，随机访问。查找、插入、删除时间复杂读为O(1)。

    ●向量(vector):类似数组(内部是线性存储),支持下标访问，在尾部添加和删除元素效率高，中间执行添加删除操作可以，但效率很低。  //可以扩容的数组 //数组结构
    ●双端队列(deque):支持下标访问(头尾两端都可添加/删除操作)。 //与向量vector很相似 //数组结构
    ●列表(list) :在任何位置添加和删除操作都很方便，不支持下标访问。 //底层是双向链表 //链表结构
    笔记：
        1、基本容器或线性容器：向量vector、双端队列deque、列表list
        2、线性容器，从存储方式上说，都有某种办法可以拿到下一个元素。
        3、基本容器，的意思是后面的容器都是从这3个容器扩展出来的
        
    ●堆栈(stack) :支持在-端存储和提取元素。
    ●队列(queue) :支持从前端提取，后端压入元素。 //类似，普通的门诊
    ●优先队列(priority_queue) :类似队列，但所提取的是具有最高优先级的元素(默认大者优先)。 //类似，急诊，重症优先
    笔记：
        1、适配器容器：队列queue、优先队列priority_queue、映射map
        2、适配容器的意思是，在基础容器上封装了部分功能，形成了具有一定特点的容器
        
    ●映射(map):以key-value对的形式存储数据,以key的升序排列,key唯一(内部结构是红黑树)。//底层：平衡有序二叉树（红黑树），优点：检索效率非常高（对数级），缺点：插入删除操作非常麻烦
    ●多重映射(multimap):允许key重复出现的映射。 //key不唯一，其他与map一样
    ●集合(set):没有value的映射。
    ●多重集合(multiset):没有value的多重映射。
    笔记：
        1、关联容器：映射map、多重映射multimap、集合set、多重集合multiset。
        2、关联容器的优点：检索效率非常高（对数级），缺点：插入删除操作非常麻烦，不适合做增删操作。
    
    ●哈希散列(unordered_map)
    笔记：
        1、关联容器的无序版本：unordered_map、unordered_multimap、unordered_set、unordered_multiset
        2、无序映射 不常用，底层是哈希散列的存储方式
        3、无序映射的优点：检索效率比关联容器的略低，增删操作效率比关联容器略高
    

    容器分类
        线性容器: (向量，双端队列，列表)这类容器元素按照线性顺序排列，必须支持某种形式的next操作，以便从一个元素移动到下一个元素(迭代)。
        适配器容器:(堆栈，队列，优先队列)这类容器是对线性容器的一些接口加以屏蔽的产物。
        关联容器: (映射，多重映射，集合，多重集合)这类容器根据-一个元素相关联的key来存储或提取数据元素，存储是以key-value对的形式，按照key的升序(二叉树存储)。
        无序容器:(无序映射)使用哈希函数计算哈希值(哈希码)，根据哈希值获取容器中保存数据的位置。

设计模式：
    //单例模式：设计一个类，保证用户在使用时只能出现一个对象
         1.一个类仅有一个实例（对象）
         2.将包括，类的拷贝构造函数在内的所有构造函数私有化防止使用者在类的外部创建对象
         3.公有静态成员函数getInstance（）是获取对象实例的唯一渠道
         4.饿汉式：无论用不用，程序启动即创建
         5.懒汉事：用的时候创建，不用了即销毁--引用计数
    //饿汉式单例：笨拙的单例实现，（程序一启动，唯一的对象就已经创建了，不管用户用不用这个唯一的对象，这个对象就已经在了，浪费内存）
    //懒汉式单例：高级的实现方式，（用户不用不创建唯一对象，用的时候创建即可）
    
        /*
     template method ：模板方法，即样板
     结构化软件设计流程：1-》2-〉3-》4-〉5
         Library开发人员：
            （1）开发1、3、5三个步骤
         Appliaction开发人员：
            （1）开发2、4两个步骤
            （2）程序主流程        //方法1到5的调用流程
         调用关系：
            Appliaction开发人员 调用 Library开发人员 （向上调用） --- 早绑定
     
     面向对象软件设计流程：
         Library开发人员：
            （1）开发1、3、5三个步骤
            （2）程序主流程        //方法1到5的调用流程
         Appliaction开发人员：   //应用开发人员就比较省事了
            （1）开发2、4两个步骤
         调用关系：
            Library开发人员 调用 Appliaction开发人员 （向下调用） --- 晚绑定（早的东西调用晚的东西）
     
     模式定义：
         定义一个操作中的算法的骨架(稳定)，而将一些步骤延迟（变化)到子类中。
         Template Method使得子类中可以不改变（可复用)一个算法的结构即可重定义(override 重写）该算法的某些特定步骤。
        //假设必须有一个稳定点，才能用模板方法，否则不能模板方法。
        //假设run函数中所有方法都不稳定 或 都稳定，用设计模式没有意义
        //设计模式最大的作用就是在变化和稳定之间寻找隔离点，然后来分离他们，从而管理变化。


C++11新特性：类型推导（auto）、类型计算（decltype）、列表初始化、Lambda表达式、右值引用、移动语义
    
类型计算
    C语言: sizeof -计算类型的大小
    C++语言: typeid -可以获取类型的信息字符串
    C++11 : decltype-获取参数表达式的类型
    注意事项:类型计算由编译器确定，并不是运行期确定
    与类型推导相比 decltype1.cpp
        - 对类型的确定更加精准
            const int a= 10;
            auto b=a;//b类型推导为int
            decltype(a)c=a;//c类型计算为const int
        -可以做到类型相同但值不同
            const int a = 10;
            auto b= a;
            decltype(a)c= 100;
    三种类型计算的规则解  decltype2.cpp
        -标识符表达式，直接取表达式的类型
            int a;
            decltype(a) -> int
        -函数表达式，取函数返回值的类型
            int foo(int,int);
            decltype(foo(10,20))-> int
        -其他表达式，如果表达式的值为左值，取该左值引用的类型,如果表达式的值为右值,取该右值本身的类型;
    返回值后置  decltype3.cpp
        auto 函数名(形参表) -> decltype(表达式)

Lambda表达式
    前情概述    typeoffunc.cpp
        C++语法中函数作用域中不能再定义函数，因此没有所谓局部函数的概念。
            void foo(void){
            ...
            int bar(intx, inty){
            reutrn x + y;
            }
            cout << bar(100,200) << endl;
            ...
        但函数作用域中可以有类型，当然也可以有表达式。
        
    语法规则解   lambda.cpp
        [捕获表] (参数表) 选项->返回类型
        {
            函数体;
        };
    表像
        lambda表达式的名称是一个表达式(外观类似函数) , 但本质绝非如此。
        
    本质
        lambda表达式本质其实是一一个类
        并且最终返回值为这个类的对象
        因此对lambda表达式的调用就是该对象的函数操作符的调用 //函数操作符（小括号操作符）

        
Lambda表达式
    可以没有返回值类型，将根据return推断
    如果连return也没有，则返回值为void
    参数为void可以省略不写的
    
    捕获表
        [] -不捕获任何外部变量
        [variable] - 捕获外部变量的值(具备只读属性)
        [&variable] -按弓用捕获，指定的外部变量
        [this] -捕获this指针，访问外部对象的成员
        [=] -按值捕获所有的外部变量，也包括this
        [&] -按引用捕获所有的外部变量，也包括this
        [=,&variable] -按值捕获所有的外部变量包括this，但是指定的外部变量按引用捕获。
        [&,=variable] -按引用捕获所有的外部变量，也包括this，但是指定的外部变量按值捕获。

右值引用
左值和右值
    -可以“取”地址的值就是左值，左值通常具名
    -不可“取”地址的值就是右值，右值通常匿名
    lvalue:非常左值、常左值 --- 左值
    rvalue:纯右值 、xvalue:将亡值 -----右值

右值引用
    左值引用和右值引用
    - 左值引用只能引用左值，不能引用右值
        int a;
        int&b = a; // OK
        int c;
        int& d = a + c; //ERROR
    - 右值引用只能引用右值，不能引用左值
        int&& e = a + c;// OK
        int&& f=a;//ERROR
    - 常左值引用，既能引用左值，也能引用右值
        const int& g =a + c; // OK
        const int& h =a;// OK
    注意:
        - 有没有常右值引用呢?
         其实有的，只是没有必要，因为常右值引用，完全可以被常左值引用替代。
    笔记：
     左值引用和右值引用的差别：
         1.左值引用是别名，是外号 //左值本来就有真名，再给起一个外号
         2.右值引用就是真名。//右值本来就没有真名，是匿名内存，所以可以起一个真名。可以修改。


移动语义
    方法:
        - 资源的转移代替 资源的重建
    作用：
        - 保证功能正确的情况下，做到性能提升
        
    笔记：
        默认的拷贝构造 和 拷贝赋值 函数，在特定场景下(类中有指针成员变量) 会出现 浅拷贝的缺陷。
            this->m_psz = that.m_psz; //error,只复制地址
        将深拷贝构造函数、深拷贝赋值函数的参数改成右值引用：const String& that   ---》  String&& that
            this->m_psz = that.m_psz;  //ok
            
        String c = String("world"); // 定义c,利用c.String( String("world") ); --> 触发String类的转移构造函数  //String("world")是右值，即将死亡，应该调用转移构造函数 //右值 更匹配 右值引用
        
        String d;
        d = String("hello world"); // d.operator=( String("hello world") ) --> 触发的为转移赋值函数  //String("world")是右值，即将死亡，应该调用转移赋值函数 //右值 更匹配 右值引用



