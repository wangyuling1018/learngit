1、内存泄露，工作中怎么解决的？
    1、对象计数
    2、重载new/delete
        定义一个全局的内存信息表，用来存储内存申请的文件名及位置
        重载operator new/new[]，保存内存申请信息
        重载operator delete/delete[]，删除内存申请信息
        定义一个全局/静态常量，在程序结束时，核查内存信息表是否还存在内存申请信息，如果存在则说明发生内存泄漏，否则无内存泄漏
    3、使用工具：Valgrind、Hook Windows系统的API、使用DiagLeak检测
  
2、工作中用到的最熟练的技术是什么？例如：STL用的比较好、boost库比较了解、网络通信等

3、简历中的算法，算法指的是什么？STL的内部算法？如果回答：动态规划，会被问：工作哪些场景用到该算法？

4、说一下工作中遇到的比较难解决的问题？
    内存泄露：借助工具valgrind、引用计数、重写new/delete 。避免：智能指针、设计任务或类的时候析构中释放所有内存
    内存写坏
    死锁
    并发导致状态不对，或结果错误。r f
    

5、偶发bug，怎么解决？


6、有没有遇到死锁，怎么解决的？
    1、忘记释放锁
    2、单线程重复申请锁
    3、双线程多锁申请
    
    解决死锁：
        尽量避免同时只对一个互斥锁上锁
        互斥锁保护区域不要使用操作其他互斥锁的代码
        如果想同时对多个互斥锁上锁，要使用std：：lock
    
    


7、c++11的新特性有哪些？会抽一个问
    例如：工作中你有哪些地方用到了右值引用
    
    
8、工作中哪些地方用到了STL ？ 会抽一个容器问，例如map


9、对于内存管理的理解，比如new一块堆内存，


10、怎样正确的使用指针不发生内存泄露？
    在C++中指针经常会出错，有时候定义了指针没有初始化直接使用，或者是定义指针的时候，将指针置成NULL，但是后面
    直接对指针进行操作，这样程序也会出错。对于任何指针定义之后，都要对齐进行初始化。
    
    指针的初始化，要么是给其置为NULL；要么是给其赋值一个同类型变量的地址；要么是给其新开辟一段内存，使其指向新内存的首地址。再对其进行操作。
    
    1、在定义指针的时候注意连续声明多个指针时容易犯的错误，例如int *a,b;这种声明是声明了一个指向int类型变量的指针a和一个int型的变量b，
    这时候要清醒的记着，而不要混淆成是声明了两个int型指针。
    2、要避免使用未初始化的指针。很多运行时错误都是由未初始化的指针导致的，而且这种错误又不能被编译器检查所以很难被发现。这时的解决办法就是
    尽量在使用指针的时候定义它，如果早定义的话一定要记得初始化，当然初始化时可以直接使用cstdlib中定义的NULL也可以直接赋值为0，这是很好的编程习惯。
    3、指针赋值时一定要保证类型匹配，由于指针类型确定指针所指向对象的类型，因此初始化或赋值时必须保证类型匹配，这样才能在指针上执行相应的操作。


11、怎么实现在坐标上实现类似蛇形的坐标点（第一行从小到大，第二行从大到小）


12、A类，B类继承A类，C类继承B类，基类的拷贝构造函数会不会调用子类的拷贝构造函数？如何实现基类的拷贝构造函数调用子类的拷贝构造 ？

。，

13、信号和槽的连接函数，第5个参数 连接类型，有几种连接方式？每种方式的意思，以及工作中哪些场景会用到
    1、Qt::AutoConnection：自动连接 默认值，使用这个值则连接类型会在信号发送时决定。如果接收者和发送者在同一个线程，则自动使用Qt::DirectConnection类型。如果接收者和发送者不在一个线程，则自动使用Qt::QueuedConnection类型。

    2、Qt::DirectConnection：槽函数会在信号发送的时候直接被调用，槽函数和信号发送者在同一线程。效果看上去就像是直接在信号发送位置调用了槽函数，效果上看起来像函数调用，同步执行。
        emit语句后面的代码将在与信号关联的所有槽函数执行完毕后才被执行。
        无论槽函数所属对象在哪个线程，槽函数都在发射信号的线程内执行。

    3、Qt::QueuedConnection：信号发出后，信号会暂时被放到一个消息队列中，需等到接收对象所属线程的事件循环取得控制权时才取得该信号，然后执行和信号关联的槽函数，这种方式既可以在同一线程内传递消息也可以跨线程操作。
        emit语句后的代码将在发出信号后立即被执行，无需等待槽函数执行完毕
        槽函数在接收者所依附线程执行。


14、信号和槽函数，在多线程中的执行顺序是怎么样的？


15、一个发送端，一个接收端，如果发送端频繁往接收端发送数据，但是接收端处理不过来这些数据，有什么方法可以解决这个问题？


16、工作中怎么定位bug，通过写python脚本？具体定位什么样的工作问题？
    可使用一些内存泄露方面的工具辅助检测,提高效率..
    在有效的关键断点调试，和增加Log日志
    调试标记：适用预处理#define定义一个或多个调试标记，在代码中把调试部分使用#ifdef和#endif进行管理
    消除所有的warnning
    //搜索：c++测试
    https://blog.csdn.net/cafardhaibin/article/details/6361834?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169027843516800215032623%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169027843516800215032623&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-6361834-null-null.142^v91^insertT0,239^v3^insert_chatgpt&utm_term=C%2B%2B%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC&spm=1018.2226.3001.4187

16、数据传输的总线


17、数据存储方式

19、说一下最近做的一个项目，具体实现细节
    搭建了分布式服务器集群，包括多个跟踪服务器、一个ID服务器、多组存储服务器、http服务器、客户端
    用id服务器，产生唯一性id 与 文件路径的对应关系，保存在数据库中
    跟踪服务器：维护一个数据结构，跟踪存储服务器的状态变化，通过存储服务器发出的心跳间隔来判断是活动状态还是离线状态的。
    存储服务器：存储文件（存储路径是根据ID服务器的唯一标识计算的），向跟踪服务器发送周期性心跳包。
    web服务器：将get请求 变成 客户端的下载功能。将下载的数据 转换成 get响应 发送给客户端。支持wget命令或http协议的流媒体播放器 -- 代理服务器
    客户端上传文件：
        客户端 从 跟踪服务器获取 一组存储服务器地址列表
        客户端 从 地址列表中 选择一台存储服务器，发起上传文件请求
            存储服务器 根据id 确定存储路径，保存上传的文件
            客户机将文件元数据（文件ID、文件路径）保存在数据库中
            
    客户端下载文件：
        客户端 从 跟踪服务器获取 一组存储服务器地址列表
        客户端 从 地址列表中 选择一台存储服务器，发起下载文件请求
            存储服务器 根据文件ID查询数据库，找到文件存储路径
            通过存储路径找到下载的文件，发给客户机
            
    客户端删除文件：
        客户端 从 跟踪服务器获取 一组存储服务器地址列表
        客户端 从 地址列表中 选择一台存储服务器，发起删除文件请求
            删除存储服务器中的存储的文件
            删除数据库的文件元数据
        
        
    
    
    
    
    

20、QT界面和底层分开，如何实现？例如：实现的功能不变，但是界面需要用MFC写



21、web


