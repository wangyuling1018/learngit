
标准模板库(STL)

STL的概念和作用
    STL的概念:全称为 Standard Template Library
    STL的作用:
        首先STL并不是语言的一部分(一开始并没有)它就是一个工具库,没有这个工具时程序员写程序都要自己做(例如:数据结构中的链表，堆栈...)
        STL模板库内部使用模板使操作更加泛化,STL内部三大部分构成(容器,泛型以及算法)

数组结构和链表结构
    数组结构
        优点:随机访问方便，速度快效率高。
        缺点:插入删除不方便,效率低(内存空间分布的限制)
    链表结构
        优点:插入删除操作方便，效率高。
        缺点:随机访问不方便效率低，往往就是通过在遍历过程中对给定的条件进行检测。
    总结:STL模板库中所提供的容器类,结合了数组和链表的优缺点，使用户从诸如内存管理的细节中得以解脱(对数组和链表的操作进行了封装)

常用容器概述
    ●向量(vector):类似数组(内部是线性存储),支持下标访问，在尾部添加和删除元素效率高，中间执行添加删除操作可以，但效率很低。  //可以扩容的数组 //数组结构
    ●双端队列(deque):支持下标访问(头尾两端都可添加/删除操作)。 //与向量vector很相似 //数组结构
    ●列表(list) :在任何位置添加和删除操作都很方便，不支持下标访问。 //底层是双向链表 //链表结构
    笔记：
        1、基本容器或线性容器：向量vector、双端队列deque、列表list
        2、线性容器，从存储方式上说，都有某种办法可以拿到下一个元素。
        3、基本容器，的意思是后面的容器都是从这3个容器扩展出来的
        
    ●堆栈(stack) :支持在-端存储和提取元素。
    ●队列(queue) :支持从前端提取，后端压入元素。 //类似，普通的门诊
    ●优先队列(priority_queue) :类似队列，但所提取的是具有最高优先级的元素(默认大者优先)。 //类似，急诊，重症优先
    笔记：
        1、适配器容器：队列queue、优先队列priority_queue、映射map
        2、适配容器的意思是，在基础容器上封装了部分功能，形成了具有一定特点的容器
        
    ●映射(map):以key-value对的形式存储数据,以key的升序排列,key唯一(内部结构是红黑树)。//底层：平衡有序二叉树（红黑树），优点：检索效率非常高（对数级），缺点：插入删除操作非常麻烦
    ●多重映射(multimap):允许key重复出现的映射。 //key不唯一，其他与map一样
    ●集合(set):没有value的映射。
    ●多重集合(multiset):没有value的多重映射。
    笔记：
        1、关联容器：映射map、多重映射multimap、集合set、多重集合multiset。
        2、关联容器的优点：检索效率非常高（对数级），缺点：插入删除操作非常麻烦，不适合做增删操作。
    
    ●哈希散列(unordered_map)
    笔记：
        1、关联容器的无序版本：unordered_map、unordered_multimap、unordered_set、unordered_multiset
        2、无序映射 不常用，底层是哈希散列的存储方式
        3、无序映射的优点：检索效率比关联容器的略低，增删操作效率比关联容器略高
    

    容器分类
        线性容器: (向量，双端队列，列表)这类容器元素按照线性顺序排列，必须支持某种形式的next操作，以便从一个元素移动到下一个元素(迭代)。
        适配器容器:(堆栈，队列，优先队列)这类容器是对线性容器的一些接口加以屏蔽的产物。
        关联容器: (映射，多重映射，集合，多重集合)这类容器根据-一个元素相关联的key来存储或提取数据元素，存储是以key-value对的形式，按照key的升序(二叉树存储)。
        无序容器:(无序映射)使用哈希函数计算哈希值(哈希码)，根据哈希值获取容器中保存数据的位置。

    常用容器的共同特点
        >所有容器都支持拷贝构造 和 拷贝赋值。 //容器本身支持拷贝构造 和 拷贝赋值。
        >相同类型的两个容器之间可以通过==进行相等性判断。
        >容器存储的为数据的副本这也就意味着存入容器中的对象应支持拷贝构造和拷贝赋值。//容器中的数据应该支持拷贝构造和拷贝赋值
        >通常情况下被存放到容器中的对象应支持无参构造。//vector、deque支持无参构造，可以扩容

    迭代器
        顺序迭代器
            一次只能向后或者向前迭代一步，只支持++和--运算。
        随机迭代器
            即能一次向后或者向前迭代一步，也可以迭代多步，除了支持++和--，也支持对整数的加减运算。 //除了支持++和--，也支持+n和-n
        除了向量和双端队列以及优先队列支持随机迭代器以外，其余容器只支持顺序迭代器。
        正向迭代器:起始迭代器指向向量第一个元素位置，终止迭代器指向向量最后一个元素的下个位置，增操作向容器的尾部移动，减操作向容器的首部移动。
        反向迭代器:起始迭代器指向向量的最后一个元素的位置，终止迭代器指向向量第一个元素的前一个位置，增操作向容器的首部移动，减操作向容器的尾部移动。
        四个迭代器类:
            iterator（正向非常迭代类） / const_iterator（正向常迭代类） / reverse_iterator（反向非常迭代类） / const_reverse_iterator（反向常迭代类）
        八个迭代器对象:
            begin() / end()                   //对应的迭代类：iterator（正向非常迭代类）
            cbegin()const / cend()const       //对应的迭代类：const_iterator（正向常迭代类）
            rbegin() / rend()                 //对应的迭代类：reverse_iterator（反向非常迭代类）
            crbegin()const / crend()const     //对应的迭代类：const_reverse_iterator（反向常迭代类）


向量容器
    成员函数
        front() / back() / insert() / erase()
        push_back() / pop_back() / empty() / clear()
        size() -向量维护元素个数
        resize() -设置向量元素个数
        capacity() -获取向量容量
        reserve() -设置向量的容量
    初始化
        ●向量中的元素被存储在一段连续的内存空间中。
        ●向量维护的内存空间会随着新元素的增加而自动增长。
        ●内存空间的连续性不会妨碍向量元素的增加，如果内存空间无法满足新元素的增加，向量会开辟新的足够的连续内存空间，并把原内存空间的数据复制到新的内存空间，释放原内存空间。
        ●向量的增加会伴随着内存空间的分配和释放，元素复制和销毁等额外开销。
        ●如果能够在创建向量时，合理预分配一些空间将很大程度.上缓解这些额外开销。
    
    迭代器的使用
        增操作:insert
        删操作: erase
        改操作：
        查操作:find
        排序操作:sort

双端队列
    双端队列和向量的差别
        和向量差别就是首尾两端同样都是开放的，因此他同时提供了首尾两端增删元素的接口。 //多了push_front() /pop_front()
        没有提供设置/获取容量的函数，设置和获取容器大小的函数存在。

