//
//  01_vector.cpp
//  C++learning
//
//  Created by 王育玲 on 2023/3/7.
//

/*
 STL的概念和作用
 STL的概念：全称为Standard Template Library
 STL的作用：首先STL并不是语言的一部分（一开始并没有）它就是一个工具库，没有这个工具时程序员都要自己做（例如：数据结构中的链表、堆栈...）
 
 STL模板库内部使用模板使操作更加泛化，STL内部三大部分构成（容器，泛型以及算法）
 
 数组结构和链表结构：
 数组结构
    优点：随机访问方便，速度快效率高
    缺点：插入删除不方便，效率低（内存空间分布的限制）
 链表结构
    优点：插入删除操作方便，效率高
    缺点：随机访问不方便效率低，往往就是通过在遍历过程中对给定的条件进行检测
 
 总结：STL模板库中所提供的容器类，结合了数组和链表的优缺点，使用户从诸如内存管理的细节中得以解脱（对数组和链表的操作进行了封装）
 
 顺序迭代器：一次只能向后或者向前迭代一步，只支持++和--运算。
 随机迭代器：既能一次向后或者向前迭代一步，也可以迭代多步，除了支持++和--，也支持对整数的加减法运算（+n操作）
 除了向量、双端队列、优先队列支持随机迭代器以外，其余容器只支持顺序迭代器
 
 正向迭代器：起始迭代器指向 向量第一个元素为位置，终止迭代器指向 向量最后一个元素的下一个位置，增操作 向容器的尾部移动，减操作 向容器的首部移动
 反向迭代器：起始迭代器指向 向量的最后一个元素的位置，终止迭代器指向 向量第一个元素的前一个位置，增操作 向容器的首部移动，减操作 向容器的尾部移动
 四个迭代器类：iterator/ const_iterator /reverse_iterator /const_reverse_iterator
 八个迭代器对象：
    begin() / end()
    begin()const / end()const
    rbegin() / rend()
    rbegin()const / rend()const
 */

/*向量容器-vector
 成员函数
    front()/back()/insert()/erase()
    push_back()/pop_back()/empty()/clear()
    size() -向量维护元素的个数
    resize() -设置向量元素的个数
    capacity() -获取向量容量
    reserve() -设置向量的容量
 
 初始化
    1.向量中的元素被存储在一段连续的内存空间中
    2.向量维护的内存空间会随着新元素的增加而自动增长
    3.内存空间的连续性不会妨碍向量元素的增加，如果内存空间无法满足新元素的增加，向量会开辟新的足够的连续内存空间，并把原内存空间的数据复制到新的内存空间，释放原内存空间
    4.向量的增加会伴随着内存空间的分配和释放，元素的复制和销毁等额外开销
    5.如果能够在创建向量时，合理预分配一些空间将很大程度上缓解这些额外开销

 
 */

//范型：类型的泛化
//数组结构 和 链表结构 是数据结构的2种最基本的类型，其他复杂的类型，都可以从这2种衍生出来。

//向量 可以理解为 自动扩容的数组
//双端队列 和 向量 的用法非常相似
//不支持下标 表示随机访问不方便
//基本容器（线性容器）：向量、双端队列、列表。  //基本容易：其他复杂的类型，都可以从这3种衍生出来  //线性容器：存储方式上说，都有办法获取下一个元素。

//适配器容器：堆栈、队列、优先队列。在基本容器的基础上封装了部分功能，把一部分功能给屏蔽掉了，形成了具有一定特点的容器。
//关联容器：映射（map）、多重映射（multimap）、集合（set）、多重集合（multiset）。适合做大量检索，不适合增删
//无序容器：哈希散列（unordered_map）

#if 0
#include<iostream>
#include<vector>
#include<string.h>
using namespace std;
//向量容器-vector
//验证初始化
class Student{
public:
    Student(string const& name) : m_name(name){
       cout << "缺省构造了" << m_name << "(" << this <<")" << endl;
    }
    Student(Student const& that):m_name(that.m_name){
        cout << "用" << that.m_name << "(" << &that << ") 拷贝构造了"
             << m_name << "(" << this << ")" << endl;
    }
    ~Student(){
        cout << "析构了" << m_name << "(" << this << ")" << endl;
    }
private:
    string m_name;
};

int main(){
    vector<Student> vs;
    //vs.reserve(10);   //提前设置足够的空间，否则会增加很多额外的开销
    vs.push_back(Student("张三"));
    vs.push_back(Student("李四"));
    vs.push_back(Student("王武"));
    vs.push_back(Student("马六"));
    vs.push_back(Student("田七"));
    
    cout << "大小：" << vs.size() << "容量：" << vs.capacity() << endl;
    
    //vs.resize(12); //resize可以比容量大，要扩容；比容量小，就会析构后面的几个，删除后面的几个数据
    //cout << "大小：" << vs.size() << "容量：" << vs.capacity() << endl;
    
    
    getchar();
    
    return 0;
}
#endif
/*无vs.reserve(10);的结果       //增加一个数据，就会搬一次家（从小找一块地方存放原来的所有数据）
 缺省构造了张三(0x7ff7bfeff3f8)
 用张三(0x7ff7bfeff3f8) 拷贝构造了张三(0x6000002052c0)
 析构了张三(0x7ff7bfeff3f8)
 缺省构造了李四(0x7ff7bfeff3b8)
 用李四(0x7ff7bfeff3b8) 拷贝构造了李四(0x600000c04978)
 用张三(0x6000002052c0) 拷贝构造了张三(0x600000c04960)
 析构了张三(0x6000002052c0)
 析构了李四(0x7ff7bfeff3b8)
 缺省构造了王武(0x7ff7bfeff388)
 用王武(0x7ff7bfeff388) 拷贝构造了王武(0x600002604030)
 用李四(0x600000c04978) 拷贝构造了李四(0x600002604018)
 用张三(0x600000c04960) 拷贝构造了张三(0x600002604000)
 析构了李四(0x600000c04978)
 析构了张三(0x600000c04960)
 析构了王武(0x7ff7bfeff388)
 缺省构造了马六(0x7ff7bfeff358)
 用马六(0x7ff7bfeff358) 拷贝构造了马六(0x600002604048)
 析构了马六(0x7ff7bfeff358)
 缺省构造了田七(0x7ff7bfeff328)
 用田七(0x7ff7bfeff328) 拷贝构造了田七(0x600003700060)
 用马六(0x600002604048) 拷贝构造了马六(0x600003700048)
 用王武(0x600002604030) 拷贝构造了王武(0x600003700030)
 用李四(0x600002604018) 拷贝构造了李四(0x600003700018)
 用张三(0x600002604000) 拷贝构造了张三(0x600003700000)
 析构了马六(0x600002604048)
 析构了王武(0x600002604030)
 析构了李四(0x600002604018)
 析构了张三(0x600002604000)
 析构了田七(0x7ff7bfeff328)
 大小：5容量：8
 */


/*vs.reserve(10);  结果：      //不用增加一个数据就搬一次家，只是复制一下数据即可
 缺省构造了张三(0x7ff7bfeff3e8)
 用张三(0x7ff7bfeff3e8) 拷贝构造了张三(0x600003d04000)
 析构了张三(0x7ff7bfeff3e8)
 缺省构造了李四(0x7ff7bfeff3b8)
 用李四(0x7ff7bfeff3b8) 拷贝构造了李四(0x600003d04018)
 析构了李四(0x7ff7bfeff3b8)
 缺省构造了王武(0x7ff7bfeff388)
 用王武(0x7ff7bfeff388) 拷贝构造了王武(0x600003d04030)
 析构了王武(0x7ff7bfeff388)
 缺省构造了马六(0x7ff7bfeff358)
 用马六(0x7ff7bfeff358) 拷贝构造了马六(0x600003d04048)
 析构了马六(0x7ff7bfeff358)
 缺省构造了田七(0x7ff7bfeff328)
 用田七(0x7ff7bfeff328) 拷贝构造了田七(0x600003d04060)
 析构了田七(0x7ff7bfeff328)
 大小：5容量：10
 */
