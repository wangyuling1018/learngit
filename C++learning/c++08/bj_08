笔记：
    int a; //ok ，a后面可以修改
    const int b; //error ,b不能修改，永远都是随机数，没有意义，必须给常量初始化
    int& c; //error，c是引用，引用不能更改，必须初始化
    
    
    1. 自定义转换 ?  程序员自己定制转换（利用 类型转换构造函数来定制转换规则）
     
    2. 静态类型转换的第二个应用场景：自定义转换

    3. 所有类型转换 都不会更改源数据本身，都是产生一个匿名对象(变量)

    4. 构造函数 和 析构函数   的作用
        构造函数的作用： 定义 对象的各个成员变量（造包子馅）****************************
        析构函数的作用： 销毁 对象的各个成员变量（吃包子馅）****************************


初始化表  initlist.cpp
    - 通过在类的构造函数中使用初始化表，可以通知编译器该类的成员变量如何被初始化
    - 类中的基本类型成员变量，最好在初始化表中显式指明如何初始化，否则初值不确定。
    - 类中的类类型成员变量，也最好在初始化表中显式指明如何初始化，否则将调动相应类型的无参构造函数。
初始化表 hastoinitlist.cpp
    一类的常量型和引用型成员变量，必须在初始化表中显式初始化。
    -类的成员变量按其在类中的声明顺序依次被初始化， 而与其在初始化表中的顺序无关。


类型转换构造函数  consconv.cpp
    - 形如:
        class 目标类型{
            目标类型(const 源类型& src){...}
        };
        的构造函数被称为类型转换构造函数。
    -用于
        √利用一个已定义的对象，来定义另一个不同类型的对象
        √ 实现从源类型到目标类型的隐式类型转换的目的

构造函数
    - 通过explicit关键字，可以强制这种通过类型转换构造函数实现的类型转换必须通过静态转换:显式地进行.
    class 目标类型{
        explicit 目标类型(const 源类型& src) { ... }
    };


类型转换构造函数被调用时 consconvtime.cpp
    √用已定义对象作为不同类型对象的构造实参
    √用已定义对象给不同类型的对象初始化或赋值
    √以对象的形式向函数传递不同类型的参数
    √从函数中返回不同类型的对象

析构函数
    析构函数的函数名就是在类名前面加"~",没有返回类型也没有参数，不能重载
    在销毁对象之前一刻自动被调用，且仅被调用一次
        -对象离开作用域
        -delete操作符
    作用:销毁 对象的各个成员变量。
    如果-一个类没有定义析构函数，那么编译器会为其提供一个默认析构函数
        - 对基本类型的成员变量，什么也不做
        - 对类类型的成员变量，调用相应类型的析构函数
        - 销毁对象的各个成员变量
    对象的销毁过程
        - 调用析构函数
            √ 执行析构函数的代码
            √调用成员变量的析构函数
            √释放对象各成员变量所占内存空间
        一释放整个对象所占用的内存空间
析构函数 hastodescon.cpp
    通常情况下，若对象在其生命周期的最终时刻，并不持有任何动态分配的资源，可以不定义析构函数
    但若对象在其生命周期的最终时刻，持有动态资源则必须自己定义析构函数，释放对象所持有的动态资源
    析构函数的功能并不局限在释放资源上，它可以执行我们希望在对象被释放之前执行的任何操作

深浅拷贝构造与拷贝赋值

拷贝构造与拷贝赋值 Copybytes.cpp
    - 如果类不提供拷贝构造和拷贝赋值编译器将提供默认的拷贝构造和拷贝赋值,
        而默认的拷贝构造和拷，贝赋值函数，对于指针型成员变量都是只复制地址,
        而并不是复制地址指向的数据，这将导致浅拷贝问题
    - 为了获得完整意义上的对象副本，必须自己定义拷贝构造和拷贝赋值，针对指针型成员变量做深拷贝
    - 相对于拷贝构造，拷贝赋值需要做更多的工作
        -避免自赋值
        -分配新资源
        - 拷贝新内容
        - 释放旧资源
        - 返回自引用
    - 无论是拷贝构造还是拷贝赋值，其默认实现对任何类型的指针成员都是简单地复制地址，因此应尽量避免使用指针型成员变量
    - 出于具体原因的考虑，确实无法实现完整意义上的拷贝构造和拷贝赋值，可将它们私有化，以防误用
    - 如果为一个类提供了自定义的拷贝构造函数，就没有理由不提供相同逻辑的拷贝赋值运算符函数

