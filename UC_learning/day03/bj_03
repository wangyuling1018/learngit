背景：a.out进程执行完成如果需要用10秒，动态库也会加载到内存中等待被使用，使用动态库只需要1秒，
    却需要在内存中等待10秒。。。站着茅坑不拉屎。。。。然后就有了动态库的动态加载。
    
动态库的动态加载
    1、在程序执行的过程中，开发人员可以动态加载共享库(什么时候用什么时候加载)
    2、在程序中动态加载共享库需要调用一组特殊的函数，它们被声明于一个专门的头文件中，并在一个独立的库中予以实现。
    3、使用这组函数需要包含此头文件，并链接该库
        #include<dlfcn.h>
        -ldl
 
    void* dlopen(char const* filename, int flag);
        功能:将共享库载入内存并获得其访问句柄
        参数:filename:动态库路径，若只给文件名不带目录，则LD_LIBRARY_PATH环境变量的值搜索动态库
            flag:加载方式，可取以下值:
                RTLD_LAZY - 延迟加载，使用动态库中的符号时才真的加载进内存。
                RTLD_NOW - 立即加载。
        返回值:成功返回动态库的访问句柄，失败返回NULL。
        句柄:句柄唯一地标识了系统内核所维护的共享库对象，将作为后续函数调用的参数
    笔记：
        延迟加载：库什么时候用，什么时候加载到内存中。
        立即加载：库立即加载到内存中。
        返回值返回句柄：返回一个地址，这个地址就叫句柄，代表的是载入内存的库。后续使用库可以用该地址表示。

    void* dlsym(void* handle, char const* symbol);
        功能:从已被加载的动态库中获取特定名称的符号地址
        参数: handle 动态库访问句柄
             symbol 符号名
        返回值:成功返回给定符号的地址，失败返回NULL。
        该函数所返回的指针为void*类型，需要造型为与实际目标类型相一致的指针，才能使用。
        例如:
        ➢int (*p_add)(int,int) = (int (*)(int,int)dlsym(handle," add" );
        ➢if(!p_add ){
            fprintf(stder,"获取地址失败! \n" );
            exit(EXIT FAILURE);
        }
        ➢int sum = p_add(30,20);
    笔记：
        使用库中的函数，需要知道库中函数的地址。
        dlsym获取库中的相关的数据（包括函数、变量、类等）的地址的。
        Char* 类型的指针，一般都传的字符串。
        Handle：我刚刚载入内存的库，即dlopen的返回值的句柄。
        Symbol：我要用库中数据的地址。例如传函数名、变量名、类等。
        “add”返回的是地址：返回具体数据（包括函数、变量、类等）的地址。
    

    int dlclose(void* handle);
        功能:从内存中卸载动态库
        参数:handle动态库句柄
        返回值:成功返回0,失败返回非0。
        所卸载的共享库未必会真的从内存中立即消失，因为其他程序可能还需要使用该库
        只有所有使用该库的程序都显示或隐式地卸载了该库，该库所占用的内存空间才会真正得到释放
        无论所卸载的共享库是否真正被释放，传递给dlclose函数的句柄都会在该函数成功返回后立即失效
    笔记：
        库加载到内存使用完后记得卸载。
        动态库又叫共享库，可以被多个进程同时使用。使用该库的所有进程都卸载该库，该库才能从内存中消失。

    char* dlerror(void);
    功能:获取在加载、使用和卸载共享库过程中所发生的错误
    返回值:有错误则返回指向错误信息字符串的指针，否则返回NULL。
    例如:
    void* handle = dlopen( “libmath.so”,RTLD_NOW);
    if(!handle){
        fprintf(stderr,"dlopen:%s\n",dlerror());
        exit(EXIT_FAILURE);
    }
    
    辅助工具
    查看符号表:nm
        列出目标文件、可执行程序、静态库、或共享库中的符号例:nm libmath.a
    查看依赖:ldd
        查看可执行文件或者共享库所依赖的共享库
        例:ldd a.out


fprintf(stderr,“dlopen:%s\n”,dlerror());通过标准错误往显示器上是输出字符串。
printf是把一个串输出到屏幕里。
fprintf是把一个串输出的文件里。
stdin标准输入，对应的是键盘文件。
stdout标准输出，对应的是显示器文件。由缓冲区再到显示器。缓冲区的内容什么时候才能到屏幕上有3个条件：1】输出的串有“\n”；2】输出的足够多填满缓冲区。3】等到程序结束的时候。
stderr 标准错误，对应的是显示器文件。无缓冲区直接到显示器。希望一旦出错，这个错误信息能够里面被看到。标准错误能够及时显示到屏幕。

man手册：
man 1 命令：查命令，例如man 1 ls查ls命令怎么用的。
man 2 系统函数：查系统调用。例如man 2 open查open函数怎么用。
man 3 标准库函数：查标准库函数。例如man 3 fopen查fopen函数怎么用。

静态库和动态库都是二进制文件。
nm + 库名：查看库的结构。

ldd 查看具体的某个可执行程序的执行时所需要依赖的库。

错误处理：
*写代码有2个错误：1、语法错误--->编译阶段；2、逻辑错误--->执行阶段。
*设计函数一般通过设计返回值来判断是否执行成功。
*调用函数失败了，怎么知道失败的原因，通过错误号。操作系统对每一个失败原因有一个编号，这个编号就是错误号。
 函数出错的原因一定是这些错误号中的一个，不会是其他的错误，操作系统已经汇总了所有的错误。
   在/usr/include/x86.../errno-bash.h中：
*错误号存入全局变量errno中：
    int errno --> 0
    malloc();//错误原因 ---> 编号 ---〉存入errno


错误的处理和表示
    1、少年!错在哪了?
    2、针对因为运行环境、人为操作等原因导致的错误，程序的设计者需要提前有所考虑，向函数的调用者提供必要的信息，以明确发生了错误，以及具体是什么错误。
    3、习俗:如果一个函数的返回值是一个指针，那么就用返回NULL指针的方式表示错误;如果一个函数的合法返回值属于某个有限的值域，
        那么就用该值域以外的值表示错误;如果一个函数不需要返回数据，那么就用返回0表示成功，返回-1表示失败。
        
通过错误号了解具体的错误原因
    ➢系统于定义的整数类型全局变量errno中存储了最近一次系统调用的错误编号
    ➢头文件errno.h中包含了对errno全局变量的外部声明和各种错误号的宏定义
    ➢/usr/include/errno.h
    ➢/usr/include/asm-generic/errno.h
    ➢/usr/include/asm-generic/erno-base.h

#include<string.h>
char* strerror(int errnum)
    功能:将整数形式的错误号转换为有意义的字符串参数:errnum错误号
    返回值:返回与参数错误号对应的描述字符串
    
#include <stdio.h>
void perror(char const*tag);
    功能:在标准出错设备上打印最近一次函数调用的错误信息
    参数:tag为用户自己制定的提示内容，输出时，会自动在该提示内容和错误信息之间添加冒号进行分隔。
    
注意:
    虽然所有的错误编号都不是零，但是因为在函数执行成功的情况下存储错误编号的全局变量errno并不被清零，
    所以不能用该变量的值是否为零作为最近一次函数调用是否成功的判断条件。正确的做法是，先根据函数的返回值判断其是否出错，
    在确定出错的前提下，再根据errno的值判断具体出了什么错。
