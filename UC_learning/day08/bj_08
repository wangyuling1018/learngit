文件描述符的复制
    #include < unistd.h>
    int dup(int oldfd);
        功能:复制文件描述符表的特定条目到最小可用项:
        参数: oldfd: 源文件描述符
        返回值:成功返回目标文件描述符，失败返回-1
    ●dup函数将oldfd参数所对应的文件描述符表项复制到文件描述符表第一个空闲项中，同时返回该表项对应的文件描述符。
     dup函数返回的文件描述符一定是调用进程当前未使用的最小文件描述符。
    ●dup函数只复制文件描述符表项，不复制文件表项和v节点，因此该函数所返回的文件描述符可以看做是参数文件描述符oldfd的副本，它们标识同一个文件表项
    ●注意，当关闭文件时，即使是由dup函数产生的文件描述符副本，也应该通过close函数关闭，因为只有当关联于一个文件表项的所有文件描述符都被关闭了，
     该文件表项才会被销毁，类似地，也只有当关联于一个v节点的所有文件表项都被销毁了，v节点才会被从内存中删除，因此从资源合理利用的角度讲，凡是明确
     不再继续使用的文件描述符，都应该尽可能及时地用close函数关闭
    ●dup函数究竟会把oldfd参数所对应的文件描述符表项，复制到文件描述符表的什么位置，程序员是无法控制的，这完全由调用该函数时文件描述符表的使用情况决定，
     因此对该函数的返回值做任何约束性假设都是不严谨的
    ●由dup函数返回的文件描述符与作为参数传递给该函数的文件描述符标识的是同一个文件表项，而文件读写位置是保存在文件表项而非文件描述符表项中的，
     因此通过这些文件描述符中的任何一个，对文件进行读写或随机访问，都会影响通过其它文件描述符操作的文件读写位置。这与多次通过open函数打开同一个文件不同

    #include <unistd.h>
    int dup2(int oldfd, int newfd);
        功能:复制文件描述符表的特定条目到指定项:
        参数:oldfd:源文件描述符
            newfd:目标文件描述符
        返回值:成功返回目标文件描述符(newfd)，失败返回-1。
    ●dup2函数在复制由oldfd参数所标识的源文件描述符表项时，会先检查由newfd参数所标识的目标文件描述符表项是否空闲，若空闲则直接将前者复制给后者，
     否则会先将目标文件描述符newfd关闭，使之成为空闲项，再行复制。
     笔记：
        oldfd与newfd指向同一个文件表项，文件表项中存的文件读写位置，通过oldfd、newfd操作的是同一个文件读写位置。

文件锁
    读写冲突
        ➢如果两个或两个以上的进程同时向一个文件的某个特定区域写入数据，那么最后写入文件的数据极有可能因为写操作的交错而产生混乱
        ➢如果一个进程写而其它进程同时在读一个文件的某个特定区域，那么读出的数据极有可能因为读写操作的交错而不完整
        ➢多个进程同时读一一个文件的某个特定区域，不会有任何问题，它们只是各自把文件中的数据拷贝到各自的缓冲区中，并不会改变文件的内容，相互之间也就不会冲突
        ➢由此可以得出结论，为了避免在读写同一个文件的同一个区域时发生冲突，进程之间应该遵循以下规则，如果一个进程正在写，那么其它进程既不能写也不能读，
         如果一个进程正在读，那么其它进程不能写但是可以读

    文件锁
        ➢为了避免多个进程在读写同-一个文件的同-一个区域时发生冲突，Unix/Linux系统引入了文件锁机制，并把文件锁分为读锁和写锁两种，它们的区别在于，
        对-一个文件的特定区域可以加多把读锁，对一一个文件的特定区域只能加一把写锁
        ➢基于锁的操作模型是:读/写文件中的特定区域之前，先加上读/写锁，锁成功了再读/写，读/写完成以后再解锁
            文件的某个区域当前拥有锁         期望加锁
                                              读锁    写锁
                                    无任何锁    OK     OK
                                    多把读锁    OK     NO
                                    -把写锁     NO     NO
        //读和写、写和写有冲突，读和读无冲突
        //可以向同一个文件，添加多把写锁（文件特定区域不同即可）

        ➢假设进程A期望访问某文件的A区，同时进程B期望访问该文件的B区，而A区和区存在部分重叠，分情况讨论
            第一种情况:进程A正在写，进程B也想写
            第二种情况:进程A正在写，进程B却想读
            第三种情况:进程A正在读，进程B却想写
            第四种情况:进程A正在读，进程B也想读
            
    #include < fcntl.h>
    int fcntl(int fd, F_SETLK/F_SETLKW, struct flock* lock);
        ➢功能:加解锁
        ➢参数: F_SETLK非阻塞模式加锁，F_SETLKW阻塞寒模式加锁
              lock 对文件要加的锁
        ➢返回值:成功返回0,失败返回-1
        //阻塞加锁：加不上就死等，程序就停留在fcntl函数上，程序不执行不返回。
        //非阻塞加锁：加不上，程序就去做其他操作，过一会再来调用fcntl函数再次加锁
        
    struct flock {
        short l_type;//锁类型:F_RDLCK/F_WRLCK/F_UNLCK
        short l_whence;//锁区偏移起点: SEEK_SET/SEEK_CUR/SEEK_END      //基准
        off_t l_start;//锁区偏移字节数                                 //偏移量
        off_t l_len;//锁区字节数员小                                   //长度，特殊：0是一直锁到文件尾
        pid_t l_pid; //加锁进程的PID，-1表示自动设置                     //默认是-1
    };
    通过对该结构体类型变量的赋值，再配合fcntl函数, 以完成对文件指定区域的加解锁操作
    //F_RDLCK 读锁 /F_WRLCK 写锁/F_UNLCK 解锁
    //确定区域：区域起始位置 + 区域长度，区域起始位置：基准 + 偏移量，区域 = 基准 + 偏移量 + 长度

    几点说明:
        当通过close函数关闭文件描述符时，调用进程在该文件描述符上所加的一切锁将被自动解除;
        当进程终止时，该进程在所有文件描述符上所加的一切锁将被自动解除;
        文件锁仅在不同进程之间起作用，同一个进程的不同线程不能通过文件锁解决读写冲突问题;
        通过fork/vfork函数创建的子进程，不继承父进程所加的任何文件锁;
        通过exec函数创建的新进程，会继承原进程所加的全部文件锁，除非某文件描述符带有FD_CLOEXEC标志。
        
    ●从前述基于锁的操作模型可以看出，锁机制之所以能够避免读写冲突，关键在于参与读写的多个进程都在按照一套模式-先加锁，再读写，
     最后解锁一按部就班地执行。这就形成了-套协议，只要参与者无一-例外地遵循这套协议，读写就是安全的。反之，如果哪个进程不遵守
     这套协议，完全无视锁的存在，想读就读，想写就写，即便有锁，对它也起不到任何约束作用。因此，这样的锁机制被称为劝谏锁或协议锁
     



