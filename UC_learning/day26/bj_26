线程同步
    ●缺省情况下，一个进程中的线程是以异步方式运行的，即各自运行各自的，彼此间不需要保持步调的协调一致
    ●某些情况下，需要在线程之间建立起某种停等机制，即一或多个线程有时必须停下来，等待另外一或多个线程执行完
     一个特定的步骤以后才能继续执行，这就叫同步
    ●并发冲突问题
        ➢任何时候只允许一个线程持有共享数据，其它线程必须阻塞于调度队列之外，直到数据持有者不再持有该数据为止
    ●资源竞争问题
        ➢任何时候只允许部分线程拥有有限的资源，其它线程必须阻塞于调度队列之外，直到资源拥有者主动释放其所拥有的资源为止
    ●条件等待问题
        ➢当某些条件一时无法满足时，一些线程必须阻塞于调度队列之外，直到令该条件满足的线程用信号唤醒它们为止

互斥锁
    ●线程间可以通过互斥锁解决资源竞争的问题。
    ●任何时候都只能一个线程持有互斥锁，即加锁成功，在其持有该互斥锁的过程中，其它线程对该锁的加锁动作都会引发阻塞，
    只有当持有互斥锁的线程主动解锁，那些在加锁动作上阻塞的线程中的一个采用恢复运行并加锁成功。
    ●pthread_mutex_t 表示互斥锁数据类型
    
    笔记：
    1、现线程同步的方式一：互斥锁。
    2、互斥锁是2个线程去抢这个把锁，哪个线程抢到，哪个线程去用。
    2、文件锁是2个进程去给已经加了多把锁的文件再去加一把锁，看看新加的锁与文件已经加的锁是否有冲突，如果有冲突就不能再加锁了，
        如果能加上就能访问文件。例如已经有了写锁，再次加一把写锁就加不了。
    
初始化互斥锁
    #include <pthread h>
    int pthread_mutex_init(pthread_mutex_t* mutex, pthread_mutexattr_t const* attr);
        功能:初始化互斥体
        参数:mutex:互斥体
            attr:互斥体属性
        返回值:成功返回0，失败返回错误码。
    也可以静态方式初始化互斥锁:
        pthread_mutex_t mutex= PTHREAD_MUTEX_INITIALIZER；  //常用的初始化锁


销毁互斥锁
    # include <pthread_h>
    int pthread_mutex_destroy(pthread_mutex_t* mutex);
        功能:销毁互斥体
        参数:mutex:互斥体
        返回值:成功返回0，失败返回错误码。

锁定互斥锁
    #include < pthread.h>
    int pthread_mutex_lock (pthread_mutex_t* mutex);
        功能:锁定互斥体
        参数: mutex互斥体
        成功:返回0，失败返回错误码


解锁互斥锁
    #include <pthread.h>
    int pthread_mutex_unlock(pthread_mutex_t*mutex);
        功能:解锁互斥锁
        参数:mutex互斥锁
        成功:返回0，失败返回错误码
        


条件变量
    ●一个线程在某种条件不满足的情况下，无法进行后续工作，这时它就可以睡入某个条件变量，这时会有其它线程为其创建条件，
    一旦条件满足可以唤醒那些在相应条件变量中睡眠的线程继续运行。
    ●通过pthread_cond_t 类型来表示条件变量
    
    笔记：
    1、实现线程同步的方式二：条件变量。
    2、条件变量是睡觉的地方。

    ●初始化条件变量
        #include < pthread.h>
        int pthread_cond_init (pthread_cond_t* cond,const pthread_condattr t* attr);
            功能:初始化条件变量
            参数: cond 条件变量
                 attr 条件变量属性
            返回值:成功返回0，失败返回错误码
        也可以静态方式初始化条件变量：
            pthread_cond_t cond = PTHREAD_COND_INITIALIZER;  //常用静态方式初始化
            
    ●销毁条件变量
        #include <pthread.h>
        int pthread_cond_destroy(pthread_cond_t*cond
            功能:销毁条件变量
            参数:cond 条件变量返回值:
            成功:返回0，失败返回错误码


    ●睡入条件变量
        #include <pthread.h>
        int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex);
            功能:睡入条件变量
            参数:cond 条件变量
                mutex 互斥锁
            返回值:成功返回0，失败返回错误码
            //条件变量一定配合互斥锁使用。
            //睡觉之前先解锁共享变量，以便其他线程使用共享变量，睡醒之前先加锁，以便唤醒之后我能使用共享变量

            ●pthread_cond_wait函数会令调用线程进入阻塞状态，直到条件变量cond收到信号为止，阻塞期间互斥体mutex被解锁
            ●条件变量必须与互斥体配合使用，以防止多个线程同时进入条件等待队列时发生竞争
                ➢线程在调用pthread_cond_wait函数前必须先通过pthread_mutex_lock函数锁定mutex互斥体
                ➢在调用线程进入条件等待队列之前，mutex互斥体一直处于锁定状态 ，直到调用线程进入条件等待队列后才被解锁
                ➢当调用线程即将从pthread_cond_wait函数返回时，mutex互斥体会被重新锁定，回到调用该函数之前的状态

    
    ●唤醒条件变量
        #include < pthread.h>
        int pthread_cond_signal(pthread_cond_t* cond);
            功能:唤醒在条件变量中睡眠的一个线程
            参数: cond条件变量
            返回值:成功返回0，失败返回错误码
        ●一个线程调用pthread_cond_wait函数进入阻塞状态，直到条件变量cond收到信号为止，阻塞期间互斥锁mutex会被释放。
         另一个线程通过pthread_cond_signal函数向条件变量cond发送信号，唤醒在其中睡眠的一个线程，
         该线程即从pthread_cond_wait函数中返回，同时重新获得互斥锁mutex。


生产者消费者问题
    ●生产者消费者(Producer-Consumer)问题，亦称有界缓冲区(Bounded-Buffer)问题
    ●两个线程共享一个公共的固定大小的缓冲区，其中一个线程作为生产者，负责将消息放入缓冲区;而另一个线程则作为消费者，负责从缓冲区中提取消息
    ●假设缓冲区已满，若生产者线程还想放入消息，就必须等待消费者线程从缓冲区中提取消息以产生足够的空间
    ●假设缓冲区已空，若消费者线程还想提取消息，就必须等待生产者线程向缓冲区中放入消息以产生足够的数据
    ●生产者和消费者线程之间必须建立某种形式的同步，以确保为其所共享的缓冲区既不发生上溢，也不发生下溢
    
    //在一个固定大小缓冲区中，2个线程，一个线程不停往里面放数据，一个线程不停的拿数据，当缓冲区满了，生产者不能将数据存入到缓冲区之外（上溢），
    当缓冲区空了，消费者不能拿有限缓冲区之外的数据（下溢）。
    //方案：
        当仓库满，生产者睡入条件变量，等待消费者的消费，然后唤醒生产者继续生产
        当仓库空，消费者睡入条件变量，等待生产者的生产，让后唤醒消费者继续消费
        保证缓冲区既不上溢，也不下溢。
