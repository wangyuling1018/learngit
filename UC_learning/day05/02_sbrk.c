/*
 虚拟内存的分配和释放
     ●#include <unistd.h>
     ●void* sbrk(intptr t increment);
         ➢功能:以相对方式分配和释放虚拟内存
         ➢参数: increment 堆内存的字节增量(以字节为单位)
                 >0 -分配内存
                 <0 -释放内存
                 =0 -当前堆尾
     ➢返回值:成功返回调用该函数前的堆尾指针，失败返回-1。
     
     系统内部维护一个指针，指向当前堆尾，即堆区最后一 个字节的下一一个位置, sbrk函数根据增量参数调整该指针的位置，
     同时返回该指针在调整前的位置， 其间若发现内存页耗尽或空闲，则自动追加或取消内存顶的映射

     例如:
         >p1=sbrk(4);//BBBB ^--- ---- ---- -
         >p2=sbrk(4);//BBBB BBBB ^--- ---- -
         >p3=sbrk(4);//BBBB BBBB BBBB ^--- -
         >p4=sbrk(4);//BBBB BBBB BBBB BBBB^
         >p5=sbrk(0);//BBBB BBBB BBBB BBBB^
         >p6 = sbrk(-8);//BBBB BBBB ^--- ---- -
         >p7=sbrk(-8);//^--- ---- ---- ---- -
         //B:已分配的字节
         //-:未分配的字节
         //^:当前堆尾指针
         
     笔记：
         1、sbrk(4)其中的4表示我要在物理内存中分配一个页，并完成和虚拟地址的映射。完成后这个一页的虚拟内存是完全可用的。
             sbrk是在mmap上做了封装，封装了堆尾指针控制已经分配内存的使用情况。堆尾指针是所分配的内存的使用边界，例如已经分配1页的内存，
             已经使用4个字节，那么堆尾指针指向就是第5个字节。
         2、相对方式就是调整堆尾指针的位置，堆尾指针在哪，可使用的范围就在哪。sbrk(8)的意思是基于堆尾指针再往后挪8个字节，
             意味着我可用的范围扩大了8个字节。Sbrk(-4)表示堆尾指针往前挪，可用范围在缩小，意味着释放了。
         3、sbrk是在调整堆尾指针。通过堆尾指针记录你用了多少内存。
         4、分配前的堆尾指针值和释放完后的堆尾指针值不一致，是因为操作系统的原因，不用纠结。
 */
#if 0
//sbrk函数演示
#include<stdio.h>
#include<unistd.h>
//堆尾指针在哪，可用的边界就在哪
int main(void){
    printf("%p\n",sbrk(0));//当前堆尾
    
    //分配4字节
    int* p = sbrk(sizeof(int));//基于堆尾指针，增加4个字节 //目前堆尾指针在p这里
    *p = 123;
    printf("p = %p\n",p);

    //分配8字节
    double* p2 = sbrk(sizeof(double));//基于堆尾指针，增加8个字节 //目前堆尾指针在p2这里
    *p2 = 4.56;
    printf("p2 = %p\n",p2);

    printf("%d %lg\n",*p,*p2);

    //释放12字节
    sbrk(-(sizeof(int) + sizeof(double)));

    printf("%p\n",sbrk(0));
    return 0;
}
#endif

/*
 0x102000000
 p = 0x102000000
 p2 = 0x102000004
 123 4.56
 0x10200000c
 */
