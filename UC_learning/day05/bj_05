段错误
    一切对虚拟内存的越权访问，都会导致段错误
        ➢试图访问没有映射到物理内存的虚拟内存
        ➢试图以非法方式访问虚拟内存，如对只读内存做写操作等。
    笔记：
        段错误都是在程序执行的时候产生。在编译阶段产生错误是语法问题。段错误是执行的问题。
        程序中大多数出现段错误的情况都是第一种情况。
        第一种情况：程序中经常算地址，例如指针加1等。如果地址无法算明白，找不到对应的物理地址，就会出现段错误。
        第二种情况：只读内存：虚拟地址空间中代码区的数据。代码区又叫只读常量区，代码区的数据是不允许修改的。
                  只读内存的意思不是在某个变量前面加一个const就叫只读内存了。
        

内存管理
    从底层硬件到上层应用，各层都提供了各自的内存管理接口，身处不同的开发层次，会使用不同层次的功能函数。
    用户层   应用程序         业务逻辑
            STL             标准容器/内存分配器
            C++             new/delete
            C               malloc/calloc/realloc/free
            POSIX           sbrk/brk
            Linux           mmap/munmap
    系统层   操作系统内核      kmalloc/vmalloc
            硬件驱动程序硬件   get_free_page
            硬件             硬件指令集

    笔记：
    1、内存管理：各种内存分配函数。
    2、c标准库中的malloc函数分配内存的过程是先占用内存，再将物理地址和虚拟地址做映射，然后通过虚拟地址才能操作这块内存。
    3、出现段错误的原因是由于随便的虚拟地址和物理内存没有映射，如果这个不合法的虚拟地址和物理内存的物理地址做绑定的话，
      就不会段错误了。mmap就是干这个事情的。


建立内存映射
    #include <sys/mman.h>
    void* mmap(void* start, size_t length, int prot, int flags,int fd, off t offset);
        功能:建立虚拟内存到物理内存或磁盘文件的映射:
        参数:start:映射区虚拟内存的起始地址，NULL系统自动选定后返回。
            length:映射区字节数，自动按页圆整。
            prot:映射区操作权限，可取以下值:
                    PROT_READ  -映射区可读
                    PROT_WRITE -映射区可写
                    PROT_EXEC  -映射区可执行
                    PROT_NONE  -映射区不可访问
            flags:映射标志，可取以下值:
                    MAP_ANONYMOUS -匿名映射，将虚拟内存映射到物理内存而非文件，忽略fd和offset参数
                    MAP_PRIVATE -对映射区的写操作只反映到缓冲区中并不会真正写入文件
                    MAP_SHARED -对映射区的写操作直接反映到文件中
                    MAP_DENYWRITE -拒绝其它对文件的写操作
                    MAP_FIXED -若在start上无法创建映射，则失败(无此标志系统会自动调整)
            fd:文件描述符
            offset:文件偏移量，自动按页(4K)对齐
        返回值:成功返回映射区虚拟内存的起始地址，失败返回MAP_FAILED(-1)。
    笔记：
        1、从虚拟地址start开始映射，一般情况下start为NULL，start为NULL表示我在内存中分配length个字节，
            然后让操作系统自动去选取映射起始虚拟地址，因为我也不知道操作系统中哪个虚拟地址没有被占用，
            有没有连续的虚拟地址都没有被占用，这事情让操作系统自己干。
        2、1页=4096字节，自动按页圆整：不满一页按照一页分配。
        3、prot表示映射完成后有读或写的权限。有读和写的权限用｜。
        4、flag传不同的参数在映射的时候有不同的含义.MAP_PRIVATE和MAP_SHARED是二选一，一个是私有映射，一个是共有映射。
            一般选私有映射，往物理内存写，再加MAP_ANONYMOUS。
        5、fd、offset 都是文件相关的，如果往物理内存写东西直接传0即可。

解除内存映射
    #include <sys/mman.h>
    int munmap(void* start, size_t length);
        功能:解除虚拟内存到物理内存或磁盘文件的映射:
        参数:start:映射区虚拟内存的起始地址。
            length：映射区字节数，自动按页圆整。
        返回值:成功返回0，失败返回-1.
    munmap允许对映射区的一部分解映射，但必须按页处理
    笔记：
        1、对映射区的一部分解映射：如果映射2页，可以只解除1个页的映射。
        2、#inlcude<sys/mman.h> 其中的sys是个路径，通常系统头文件在usr/include/中，sys是在usr/include/x86..中的。

内存映射的建立和解除
    char* p=(char*)mmap(NULL,8192,PROT_READ|PROT WRITE,MAP ANONYMOUS|MAP PRIVATE, 0, 0);
    if (p = = MAP_FAILED){
        perror("mmap");
        exit(EXIT FAILURE);
    }
    strcpy(p, "Hello,Memory!");
    printf("%s\n", p);
    if (munmap (p,4096)==-1){
        perror ("munmap");
        exit (EXIT FAILURE);
    }
    strcpy(p +=4096, "Hello Memory!");
    printf ("%s\n", p);
    if (munmap (p,4096) == -1){
        perror ("munmap");
        exit (EXIT FAILURE);
    }

虚拟内存的分配和释放
    ●#include <unistd.h>
    ●void* sbrk(intptr t increment);
        ➢功能:以相对方式分配和释放虚拟内存
        ➢参数: increment 堆内存的字节增量(以字节为单位)
                >0 -分配内存
                <0 -释放内存
                =0 -当前堆尾
    ➢返回值:成功返回调用该函数前的堆尾指针，失败返回-1。
    
    系统内部维护一个指针，指向当前堆尾，即堆区最后一 个字节的下一一个位置, sbrk函数根据增量参数调整该指针的位置，
    同时返回该指针在调整前的位置， 其间若发现内存页耗尽或空闲，则自动追加或取消内存顶的映射

    例如:
        >p1=sbrk(4);//BBBB ^--- ---- ---- -
        >p2=sbrk(4);//BBBB BBBB ^--- ---- -
        >p3=sbrk(4);//BBBB BBBB BBBB ^--- -
        >p4=sbrk(4);//BBBB BBBB BBBB BBBB^
        >p5=sbrk(0);//BBBB BBBB BBBB BBBB^
        >p6 = sbrk(-8);//BBBB BBBB ^--- ---- -
        >p7=sbrk(-8);//^--- ---- ---- ---- -
        //B:已分配的字节
        //-:未分配的字节
        //^:当前堆尾指针
        
    笔记：
        1、sbrk(4)其中的4表示我要在物理内存中分配一个页，并完成和虚拟地址的映射。完成后这个一页的虚拟内存是完全可用的。
            sbrk是在mmap上做了封装，封装了堆尾指针控制已经分配内存的使用情况。堆尾指针是所分配的内存的使用边界，例如已经分配1页的内存，
            已经使用4个字节，那么堆尾指针指向就是第5个字节。
        2、相对方式就是调整堆尾指针的位置，堆尾指针在哪，可使用的范围就在哪。sbrk(8)的意思是基于堆尾指针再往后挪8个字节，
            意味着我可用的范围扩大了8个字节。Sbrk(-4)表示堆尾指针往前挪，可用范围在缩小，意味着释放了。
        3、sbrk是在调整堆尾指针。通过堆尾指针记录你用了多少内存。
        4、分配前的堆尾指针值和释放完后的堆尾指针值不一致，是因为操作系统的原因，不用纠结。


    #include <unistd.h>
    int brk(void* end_data_segment);
        功能:以绝对方式分配和释放虚拟内存
        参数:end_data_segment堆尾指针的目标位置
                >堆尾指针的原位置-分配内存
                <堆尾指针的原位置-释放内存
                =堆尾指针的原位置-空操作
        返回值:成功返回0，失败返回-1。

    系统内部维护一个指针，指向当前堆尾，即堆区最后一个字节的下一个位置，brk函数根据指针参数设置该指针的位置，
    其间若发现内存页耗尽或空闲，则自动追加或取消内存页的映射
    
    例如:
        ➢p1 = sbrk (0);   //^--- ---- ---- ---- -
        >brk(p2=p1 + 4);  //BBBB ^--- ---- ---- -
        ➢brk(p3 = p2 + 4);//BBBB BBBB ^--- ---- -
        ➢brk(p4= p3 + 4); //BBBB BBBB BBBB ^--- -
        ➢brk(p5 = p4 + 4);//BBBB BBBB BBBB BBBB ^
        ➢brk (p3);        //BBBB BBBB ^--- ---- -
        ➢brk (p1);        //^--- ---- ---- ---- -
        // B:已分配的字节
        //-:未分配的字节
        // ^:当前堆尾指针

    ●事实上，sbrk和brk不过是移动堆尾指针的两种不同方法，移动过程中还要兼顾虚拟内存和物理内存之间映射关系的建立和解除(以页为单位)
    ●用sbrk分配内存比较方便，用多少内存就传多少增量参数，同时返回指向新分配内存区域的指针，但用sbrk做一次性内存释放比较麻烦，
        因为必须将所有的既往增量进行累加
    ●用brk释放内存比较方便，只需将堆尾指针设回到一开始的位置即可一次性释放掉之前分多次分配的内存，但用brk分配内存比较麻烦，
        因为必须根据所需要的内存大小计算出堆尾指针的绝对位置
    ●用sbrk分多次分配适量内存，最后用brk一次性整体释放

内存管理
    ●mmap/munmap底层不维护任何东西，只是返回一一个首地址，所分配内存位于堆中
    ●brk/sbrk底层维护一个指针，记录所分配的内存结尾，所分配内存位于堆中，底层调用mmap/munmap
    ●malloc底层维护一个线性链表和必要的控制信息，不可越界访问，所分配内存位于堆中，底层调用brk/sbrk
    ●每个进程都有4G的虚拟内存空间，虚拟内存地址只是一一个数字， 在与实际物理内存建立映射之前是不能访问的
    ●所谓内存分配与释放，其本质就是建立或解除从虚拟内存到物理内存的映射，并在底层维护不同形式的数据结构，以把虚拟内存的占用与空闲情况记录下来

系统调用
Unix应用的层次结构
    从应用程序到操作系统内核需要经历如下调用链：
              ｜      应用程序 - vi、 emacs、 gftp、firefox等
              ｜             ｜                ｜
              ｜             ｜   标准和第三方库 - C/C++、Qt、X11等
         用户态｜             ｜                ｜
         -----｜---- 系统调用 - 内核提供给外界访问的接口函数调用这些函数使进程进入内核态
         内核态｜              ｜
              ｜    系统内核 - 驱动程序、系统服务等
              
    ●Unix/Linux系统的大部分功能都是通过系统调用实现的，如open、close等
    ●Unix/Linux的系统调用已被封装成C函数的形式，但它们并不是C语言标准库的一部分
    ●标准库函数大部分时间运行在用户态，但部分函数偶尔也会调用系统调用， 进入内核态，如malloc、free等
    ●程序员自己编写的代码也可以跳过标准库，直接使用系统调用，如brk、 sbrk、mmap和munmap等，与操作系统内核交互，进入内核态
    ●系统调用在内核中实现，其外部接口定义在C库中，该接口的实现借助软中断进入丙核


