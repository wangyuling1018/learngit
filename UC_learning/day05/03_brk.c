/*
 #include <unistd.h>
 int brk(void* end_data_segment);
     功能:以绝对方式分配和释放虚拟内存
     参数:end_data_segment堆尾指针的目标位置
             >堆尾指针的原位置-分配内存
             <堆尾指针的原位置-释放内存
             =堆尾指针的原位置-空操作
     返回值:成功返回0，失败返回-1。

 系统内部维护一个指针，指向当前堆尾，即堆区最后一个字节的下一个位置，brk函数根据指针参数设置该指针的位置，
 其间若发现内存页耗尽或空闲，则自动追加或取消内存页的映射
 
 例如:
     ➢p1 = sbrk (0);   //^--- ---- ---- ---- -
     >brk(p2=p1 + 4);  //BBBB ^--- ---- ---- -
     ➢brk(p3 = p2 + 4);//BBBB BBBB ^--- ---- -
     ➢brk(p4= p3 + 4); //BBBB BBBB BBBB ^--- -
     ➢brk(p5 = p4 + 4);//BBBB BBBB BBBB BBBB ^
     ➢brk (p3);        //BBBB BBBB ^--- ---- -
     ➢brk (p1);        //^--- ---- ---- ---- -
     // B:已分配的字节
     //-:未分配的字节
     // ^:当前堆尾指针

 ●事实上，sbrk和brk不过是移动堆尾指针的两种不同方法，移动过程中还要兼顾虚拟内存和物理内存之间映射关系的建立和解除(以页为单位)
 ●用sbrk分配内存比较方便，用多少内存就传多少增量参数，同时返回指向新分配内存区域的指针，但用sbrk做一次性内存释放比较麻烦，
     因为必须将所有的既往增量进行累加
 ●用brk释放内存比较方便，只需将堆尾指针设回到一开始的位置即可一次性释放掉之前分多次分配的内存，但用brk分配内存比较麻烦，
     因为必须根据所需要的内存大小计算出堆尾指针的绝对位置
 ●用sbrk分多次分配适量内存，最后用brk一次性整体释放

 */

#if 0
//brk函数演示
#include<stdio.h>
#include<unistd.h>

int main(void){
    printf("%p\n",sbrk(0));//当前堆尾

    int* p1 = sbrk(0);
    brk(p1 + 1); //将堆尾指针往后移动4个字节
    printf("p1 = %p\n",p1);//p1没有变
    *p1 = 123;

    double* p2 = sbrk(0);
    brk(p2 + 1); //将堆尾指针往后移动8个字节
    printf("p2 = %p\n",p2);//p2没有变
    *p1 = 123;
    *p2 = 4.56;

    printf("%d %lg\n",*p1,*p2);

    //释放
    brk(p1); //将堆尾指针移动到最初始位置

    printf("%p\n",sbrk(0));
    return 0;
}
#endif

/*
 0x102800000
 p1 = 0x102800000
 p2 = 0x102800000
 -1546188227 4.56
 0x102800000
 */

