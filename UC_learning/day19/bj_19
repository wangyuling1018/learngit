消息队列
    ●消息队列是一个由系统内核负责存储和管理，并通过消息队列标识符引用的消息链表队列
    ●可以通过msgget函数创建一一个新的消息队列或获取一个已有的消息队列。
    ●可以通过msgsnd函数向消息队列的尾端追加消息,所追加的消息除了包含消息数据以外，还包含消息类型和数据长度(以字节为单位)。
    ●可以通过msgrcv函数从消息队列中提取消息，但不一定非按先进先出的顺序提取，也可以按消息的类型提取
    ●相较于其它几种IPC机制，消息队列具有明显的优势
        ➢流量控制:如果系统资源(内存)短缺或者接收消息的进程来不及处理更多的消息，则发送消息的进程会在，系统内核的控制下进入睡眠状态，
        待条件满足后再被内核唤醒，继续之前的发送过程
        ➢面向记录:每个消息都是完整的信息单元，发送端是一个消息一 一个消息地发，接收端也是-一个消息一一个消息地收，而不象管道那样收
        发两端所面对的都是字节流，彼此间没有结构上的一致性
        ➢类型过滤:先进先出是队列的固有特征，但消息队列还支持按类型提取消息的做法，这就比严格先进先出的管道具有更大的灵活性
        ➢天然同步:消息队列本身就具备同步机制，空队列不可读，满队列不可写，不发则不收，无需象共享内存那样编写额外的同步代码
    ●系统限制
        ➢可发送消息字节数上限:8192
        ➢单条队列消息总字节数上限:16384(16K)
        ➢全系统总消息队列数上限:16
        ➢全系统消息总字节数上限:262144(256K=16x16K)
笔记：
    1、队列是数据结构的一种。数据结构是数据与数据之间的关系，
    2、队列这种数据结构在维护数据关系的时候，有个非常显著的特点：先进先出。
    3、链表：指的是数据在内存中的存储方式。数据在内存中存储的时候可以是链式的、线性的。线性的就像数组一样，每个元素在内存中是依次连续的挨着的。
    链式的是一个节点一个节点之间相连，在内存中不一定是连续的。
    4、用队列这种数据结构对数据进行存储的时候，可以是线性的存储，也可以是链式的存储方式。
    5、队列是维护数据的一种方式，链表是存储数据的一种方式。
    6、消息链表队列：消息队列就是一个链表，通过这个链表存储的数据要满足队列这种先进先出的方式。
    7、进程间用消息队列去通信，实际上就是通过链表去通信。这个链表需要在通信双方使用之前给创建出来，通过键的方式创建出来。
    8、消息类型是给消息分类的，long型的。
    9、用消息队列如何实现进行通间的通信？A进程和B进程通过相同的键，来完成消息队列的创建和获取，通信过程实际上就是链表的节点的添加与删除。
    A要发送数据，就把A要发送的数据组织成一个新的节点插入到链表中。B进程要读消息的时候，按照队列的先进先出特点，从队列的头部摘取一个节点
    ，把摘掉的节点里面的消息类型、数据长度、消息数据给拿到。这样就实现来进程间的通信。
    10、摘节点的时候，可以指定消息类型，只摘某一类型的消息，这样链表就断了，断了不用管，因为消息队列是系统内核维护的，摘掉节点后消息
    链表队列怎么插入？指针怎么指？都不用管，这个是内核干的事情。
    11、流量控制：比如接收方的缓冲区是128个字节，发送方发来的数据量很大，完全不考虑我接收方的存储能力（接收能力），如果不做流量控制就会造成溢出。
    12、有的时候不做流量控制，就会造成数据丢失等等，对于消息队列而言，它天然具有流量控制，源于内核，因为操作系统对于消息队列是有资源的限制的。
    什么是资源限制？就是我在发送消息队列的时候，单条消息的字节数上限是8192，一个节点里面的消息数据不能超过8192，超过了则发不了。
    一条消息队列中所有节点里面的消息总字节数加起来上限是16k，整个系统最多允许有16条消息队列，全系统消息总字节数上限16K*16=256K。
    13、如果存储不了，向消息队列存数据的函数就会阻塞，等把节点给摘掉，腾出地方了，你在发。
    14、面向记录：一个节点一个节点的插入，一个节点一个节点的摘取（读取）。
    15、类型过滤：通过消息类型来决定接收什么样的消息。
    16、天然同步：同步是2个进程之间，它们相互之间是有配合的，有协调的。天然同步的话，我本身给你发消息，如果已经把队列填满了，
    我是不能再发的；队列是空的，已经没有节点了，已经没有消息了，是不能够再去读的。都满了我发不了，我就阻塞等你读，等你读空了，没有东西读了，
    我就阻塞等你往里面插节点。
    17、查看系统资源限制ulimit -a:
    (base) 176x212x32x15:day18 wyl$ ulimit -a
    core file size          (blocks, -c) 0
    data seg size           (kbytes, -d) unlimited
    file size               (blocks, -f) unlimited
    max locked memory       (kbytes, -l) unlimited
    max memory size         (kbytes, -m) unlimited
    open files                      (-n) 256
    pipe size            (512 bytes, -p) 1
    stack size              (kbytes, -s) 8192
    cpu time               (seconds, -t) unlimited
    max user processes              (-u) 2784


    #include < sys/msg.h>
    int msgget(key_ t key, int msgflg);
        ➢功能:创建新的或获取已有的消息队列
        ➢参数: key:键。
             msgflg:创建标志，可取以下值:
                    0 -获取，不存在即失败。
                    IPC_CREAT -创建，不存在即创建，已存在即获取。
                    IPC_EXCL  -排它，不存在即创建，已存在即失败。
                    通过位或组合读写权限。
        ➢返回值:成功返回消息队列的ID，失败返回-1。
        //获取，参数2为0
        //IPC_CREAT ｜ IPC_EXCL 一起使用的意思：不存在则创建，存在则失败。即创建一个新的。

    #include <sys/msg.h>
    int msgsnd(int msgid, void const* msgp, size t msgsz, int msgflg);
    功能:发送消息
    参数:msgid:消息队列的ID。
        msgp:指向一个包含消息类型和消息数据的内存块。该内存块的前4个字节必须是个大于0的整数，代表消息类型，其后紧跟消息数据
        msgsz:期望发送消息数据(不含消息类型)的字节数
        msgflg:发送标志，一般取O即可
    返回值:成功返回0，失败返回-1。
    //参数2 msgp是结构体，struct msgp{ long type; char data[128]或int data或double data},long 在32系统中就是4个字节，在64位系统就是8个字节。

    ●注意msgsnd函数的msgp参数所指向的内存块中包含消息类型，其值必须大于0，但该函数的msgsz参数所表示的期望发送字节数中却不包
     含消息类型所占的4个字节消息
     
    ●消息队列缺省为阻塞模式，如果调用msgsnd函数发送消息时，超过了系统内核有关消息的上限，该函数会阻塞，直到系统内核允许加入新消息为止。
    比如有消息因被接收而离开消息队列
    ●如果msgflg参数中包含IPC_NOWAIT,则msgsnd函数在系统内核中的消息已达上限的情况下不会阻塞，而是返回-1,同时置errno为EAGAIN.

    #include <sys/msg.h>
    int msgrcv(int msgid, void* msgp, size_ t msgsz, long msgtyp, int msgflg);
    ➢功能:接收消息
    ➢参数: msgid:消息队列的ID。
          msgp:指向块包含消息类型(4字节)和消息数据的内存
          msgsz:期望接收消息数据(不含消息类型)的字节数
          msgflg:接收标志, 一般取0即可
          msgtyp:消息类型，可取以下值：
                0 -提取消息队列的第一条消息
                >0-若msgflg参数不包含MSG_EXCEPT位，则提取消息队列的第一条类型为msgtyp的消息;
                    若msgflg参数包含MSG_EXCEPT位，则提取消息队列的第一条类型不为msgtyp的消息
                <0-提取消息队列中类型小于等于msgtyp的绝对值的消息，类型越小的消息越被优先提取
    ➢返回值:成功返回实际接收到的消息数据字节数，失败返回-1。
    笔记：
        msgtype取值（字节）    msgflg取值     msgrcv如何去接收消息？
        0                     0            msgrcv不区分消息类型，按照消息类型一个个往下接收
        >0（比如100）           0           从msgid消息队列中只接收>0(例如100）类型的数据，存储到msgp的消息队列中。就是说我在限制具体的消息类型。
        >0（比如100）         MSG_EXCEPT    从msgid这个消息队列中接收除了100以外的其他消息类型
        <0（比如-200）          0           从msgid这个消息队列中接收<=|-200|的消息类型数据。即<=200的消息类型。


        期望接收的消息大小    实际消息的大小    msgflg取值
        比如100字节         比如200字节      0             默认来讲是接收不了的，msgrcv函数会直接返回-1，会报错，错误码是errno = E2BIG
        比如100字节         比如200字节     MSG_NOERROR    msgrcv接收数据，只接收前100个字节，剩下100个字节不要了。
    
        msgrcv是阻塞函数，如果队列中没有消息了，但是我还想接收消息，那么msgrcv就会等，等其他进程往里面插入（存入）消息，msgrcv默认就是阻塞的，
        但是如果msgflg=IPC_NOWAIT表示msgrcv以非阻塞的方式去接收消息，如果消息类型中没有我想要的消息，则不会等待，直接返回-1，报错，错误码errno=ENOMSG。

    
    ●注意msgrcv函数的msgp参数所指向的内存块中包含消息类型，其值由该函数输出，但该函数的msgsz参数所表示的期望接收字节数以及该函数所返回的
        实际接收字节数中都不包含消息类型所占的4个字节

    ●若存在与msgtyp参数匹配的消息，但其数据长度大于msgsz参数，且msgflg参数包含MSG_NOERROR位，则只截取该消息数据的前msgsz字节返回，
      剩余部分直接丟弃;但如果msgflg参数不包含MSG_NOERROR位，则不处理该消息，直接返回-1，并置errno为E2BIG
    ●若消息队列中有可接收消息，则msgrcv函数会将消息移出消息队列，并立即返回所接收到的消息数据的字节数，表示接收成功，否则此函数会阻塞，
      直到消息队列中有可接收消息为止。若msgflg参数中包含IPC_NOWAIT位，则msgrcv函数在消息队列中没有可接收消息的情况下不会阻塞，
      而是返回-1，同时置errno为ENOMSG。

    #include <sys/msg.h>
    int msgctl(int msgid,IPC_RMID,NULL);
        功能:销毁消息队列
        参数:msgid:消息队列的ID
        返回值:成功返回0，失败返回-1
        //对方销毁消息队列后，msgrcv返回-1，且errno = EIDRM。E + id + rmove删除。


    ●基于消息队列实现进程 间通信的编程模型
        步骤    进程A       函数              进程B         步骤
        1    创建消息队列    msgget           获取消息队列    1
        2    发送接收消息    msgsnd/msgrcv    发送接收消息    2
        3    销毁消息队列    msgctl           ————          ————


IPC命令
    ●查看系统中的IPC对象
        ➢ipcs -m(memory,共享内存)
        ➢ipcs -q(message queue，消息队列)
        ➢ipcs -s(semphore，信号量集)
        ➢ipcs -a(all,所有的)
    ●删除系统中的IPC对象
        ➢ipcrm -m删除共享内存
        ➢ipcrm -q删除消息对列
        ➢ipcrm -s删除信号量集

笔记：管道（有名管道、无名管道）、IPC（共享内存、消息队列）都是在一台电脑上的2个进程间的通信，如果要跨电脑的2个进程间通信就要用网络通信了
    信号量：解决有限资源的使用，一个信号量代表一种资源的使用。
    
