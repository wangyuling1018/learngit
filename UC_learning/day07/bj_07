文件的内核结构
    ●一个处于打开状态的文件，系统会为其在内核中维护一套专门]的数据结构, 保存该文件的信息，直到它被关闭
        ➢v节点与v节点表
            ●文件的元数据和在磁盘上的存储位置都保存在其节点中，而节点保存在分区柱面组的节点表中，在打开文件时将其节点信息读入内存，
            并辅以其它的必要信息形成一一个专门]的数据结构，势必会提高对该文件的访问效率，这个存在于进程的内核空间，包含文件带点信息的
            数据结构被称为v节点。多个v节点结构以链表的形式构成v节点表
        ➢文件表项与文件表
            ●由蚊件状态标志(来自open函数的flags参数)、文件读写位置(最后-次读写的最后一一个字节的位置)和v节点指针等信息组成的
            内核数据结构被称为文件表项。通过文件表项一方面可以实时记录每次读写操作的准确位置，另一方面可以通过v节点指针访问包括
            该文件各种元数据和磁盘位置在内的节点信息。多个文件表项以链表的形式构成文件表
    ●多次打开同一个文件，无论是在同一个进程中还是在不同的进程中，都只会在系统内核中产生一个v节点
    ●每次打开文件都会产生一个新的文件表项，各自维护各自的文件状态标志和当前文件偏移，却可能因为打开的是同一个文件而共享同一个v节点
    ●打开一个文件意味着内存资源(v节点、文件表项等)的分配，而关闭一个文件其实就是为了释放这些资源，但如果所关闭的文件在其它进程中正处于打开状态，
        那么其v节点并不会/Users/wyl/C++_Projects/UC_learning/day08/bj_08被释放，直到系统中所有曾打开过该文件的进程都显式或隐式地将其关闭，其v节点才会真正被释放
    ●一个处于打开状态的文件也可以被删除，但它所占用的磁盘空间直到它的v节点彻底消失以后才会被标记为自由


文件描述符
    ●由文件的内核结构可知，-一个被打开的文件在系统内核中通过文件表项和v节点加以标识。有关该文件的所有后续操作，如读取、写入、随机访问，乃至关闭等，
     都无-例外地要依赖于文件表项和v节点。因此有必要将文件表项和v节点体现在完成这些后续操作的函数的参数中。但这又势必会将位于内核空间中的内存地址暴
     露给运行于用户空间中的程序代码。-旦某个用户进程出现操作失误，极有可能造成系统内核失稳，进而影响其它正常运行的用户进程。这将对操作系统的安全运行造成极大的威胁
    ●为了解决内核对象在可访问性与安全性之间的矛盾，Unix系统通过所谓的文件描述符，将位于内核空间中的文件表项间接地提供给运行于用户空间中的程序代码
    ●为了便于管理在系统中运行的各个进程，内核会维护一张存有各进程信息的列表，谓之进程表。系统中的每个进程在进程表中都占有一个表项。每个进程表项都包含
     了针对特定进程的描述信息，如进程ID、用户ID、组ID等，其中也包含了一个被称为文件描述符表的数据结构
    ●文件描述符表的每个表项都至少包含两个数据项一文件描述符标志和文件表项指针，而所谓文件描述符，其实就是文件描述符表项在文件描述符表中从0开始的下标
    ●作为文件描述符表项在文件描述符表中的下标，合法的文件描述符一定是个大于等于0的整数
    ●每次产生新的文件描述符表项，系统总是从下标0开始在文件描述符表中寻找最小的未使用项
    ●每关闭一个文件描述符，无论被其索的文件表项和v节点是否被删除，与之对应的文件描述符表项一定会被标记为未使用，并在后续操作中为新的文件描述符所占用
    ●系统内核缺省为每个进程打开三个文件描述符， 它们在unistd.h头文件中被定义为三个宏
        ➢#define STDIN FILENO 0//标准输入 - 键盘，scanf
        ➢#define STDOUT FILENO 1//标准输出 - 显示器，printf
        ➢#define STDERR FILENO 2//标准错误 - 显示器，perror
    注意：
        每个进程都有一个进程表，进程表中有文件描述符表，文件描述符表可以理解为一个复杂的数据结构，文件描述符就是文件描述符表中的下标，
         产生新的文件描述符时，系统总是从下标0开始在文件描述符表中寻找最小的未使用项。修改一个进程默认的文件描述符不影响其他进程。


        
文件的读写
    #include <unistd.h>
    ssize_t write(int fd, void const* buf, size_t count);
        功能:向指定的文件写入数据
        参数:fd：文件描述符
            buf：内存缓冲区，即要写入的数据
            count：期望写入的字节数     //期望与实际的有时候并不是一致的
        返回值:成功返回实际写入的字节数，失败返回-1。
       //从buf向fd写入count个字节

    #include <unistd.h>
    ssize_t read(int fd, void* buf, size_t count);
    功能:从指定的文件中读取数据
    参数:fd：文件描述符
        buf：内存缓冲区，存读取到的数据
        count：期望读取的字节数
    返回值:成功返回实际读取的字节数，失败返回-1。
    笔记：
        返回值>0，表示实际读取的字节数。
        返回值=0，表示正常读完文件。
        返回值=-1，表示失败


    
顺序与随机读写
    ●每个打开的文件都有一个与其相关的文件读写位置保存在文件表项中，用以记录从文件头开始计算的字节偏移，文件读写位置通常是
     一个非负的整数，用off_t类型表示，在32位系统上被定义为long int，而在64位系统上则被定义为long long int
    ●打开一个文件时，除非指定了OAPPEND标志，否则文件读写位置一律被设为0，即文件首字节的位置
    ●每一次读写操作都从当前的文件读写位置开始，并根据所读写的字节数，同步增加文件读写位置，为下一次读写做好准备
    ●因为文件读写位置是保存在文件表项而不是v节点中的，因此通过多次打开同一个文件得到多个文件描述符，各自拥有各自的文件读写位置
    笔记：
        1、文件读写位置决定了从哪里度，往哪里写，
        2、文件读写位置本质是整数，相对文件首的偏移量。
        3、文件读写位置随着读写操作同步增加。
            

    #include <unistd.h>
    off_t lseek(int fd, off_t offset, int whence);
        功能:人为调整文件读写位置
        参数:fd:文件描述符。
            offset: 文件读写位置偏移字节数
            whence:offset参数的偏移起点，可以如下取值:
                    SEEK_SET -从文件头(首字节)开始
                    SEEK_CUR -从当前位置(最后被读写字节的下一个字节)开始
                    SEEK_END -从文件尾(最后一个字节的下一个字节)开始
        返回值:成功返回调整后的文件读写位置，失败返回-1


    lseek函数的功能仅仅是修改保存在文件表项中的文件读写位置，并不实际引发任何I/O动作
        -lseek(fd,-7,SEEK_CUR);//从当前位置向文件头偏移7字节
        -lseek(fd,0,SEEK_CUR);// 返回当前文件读写位置
        -lseek(fd,0,SEEK_END);//返回文件总字节数
        //偏移量为整数，往前偏移，偏移量为负数，往后便宜

    ●可以通过lseek函数将文件读写位置设到文件尾之后，在超过文件尾的位置上写入数据，将在文件中形成空洞，位于文件中
     但没有被写过的字节都被设为0，文件空洞不占用磁盘空间，但被计算在文件大小之内

系统I/O与标准I/O
    ●当系统调用函数被执行时，需要在用户态和内核态之间来回切换，因此频繁执行系统调用函数会严重影响性能
    ●标准库做了必要的优化，内部维护一一个缓冲区，只在满足特定条件时才将缓冲区与系统内核同步，借此降低执行系统调用的频率，
     减少进程在用户态和内核态之间来回切换的次数，提高运行性能
     笔记：
        标准库调用       系统调用
        fopen     ->    open    //fopen底层调用open
        fread     ->    read    //fread底层调用read
        fwrite    ->    write   //fwrite底层调用write
        fclose    ->    close   //fclose底层调用close
        标准库调用比系统调用快。


文件描述符的复制
    #include < unistd.h>
    int dup(int oldfd);
        功能:复制文件描述符表的特定条目到最小可用项:
        参数: oldfd: 源文件描述符
        返回值:成功返回目标文件描述符，失败返回-1
    ●dup函数将oldfd参数所对应的文件描述符表项复制到文件描述符表第一个空闲项中，同时返回该表项对应的文件描述符。
     dup函数返回的文件描述符一定是调用进程当前未使用的最小文件描述符。
    ●dup函数只复制文件描述符表项，不复制文件表项和v节点，因此该函数所返回的文件描述符可以看做是参数文件描述符oldfd的副本，它们标识同一个文件表项
    ●注意，当关闭文件时，即使是由dup函数产生的文件描述符副本，也应该通过close函数关闭，因为只有当关联于一个文件表项的所有文件描述符都被关闭了，
     该文件表项才会被销毁，类似地，也只有当关联于一个v节点的所有文件表项都被销毁了，v节点才会被从内存中删除，因此从资源合理利用的角度讲，凡是明确
     不再继续使用的文件描述符，都应该尽可能及时地用close函数关闭
    ●dup函数究竟会把oldfd参数所对应的文件描述符表项，复制到文件描述符表的什么位置，程序员是无法控制的，这完全由调用该函数时文件描述符表的使用情况决定，
     因此对该函数的返回值做任何约束性假设都是不严谨的
    ●由dup函数返回的文件描述符与作为参数传递给该函数的文件描述符标识的是同一个文件表项，而文件读写位置是保存在文件表项而非文件描述符表项中的，
     因此通过这些文件描述符中的任何一个，对文件进行读写或随机访问，都会影响通过其它文件描述符操作的文件读写位置。这与多次通过open函数打开同一个文件不同

    #include <unistd.h>
    int dup2(int oldfd, int newfd);
        功能:复制文件描述符表的特定条目到指定项:
        参数:oldfd:源文件描述符
            newfd:目标文件描述符
        返回值:成功返回目标文件描述符(newfd)，失败返回-1。
    ●dup2函数在复制由oldfd参数所标识的源文件描述符表项时，会先检查由newfd参数所标识的目标文件描述符表项是否空闲，若空闲则直接将前者复制给后者，
     否则会先将目标文件描述符newfd关闭，使之成为空闲项，再行复制。
