
     

IPC对象的标识符和键
    ●共享内存、消息队列和信号量，这三种IPC-般被合称为XSI IPC, 它们之间有很多相似之处
    ●为了实现进程之间的数据交换，系统内核会为参与通信的诸方维护一个内核对象(类似一一个结构体变量)，记录和通信有关的各种配置参数和运行时信息,谓之IPC对象
    ●系统中的每个IPC对象都有唯一的， 非负整数形式的标识符，所有与IPC相关的操作，都需要提供IPC对象标识符
    ●与文件描述符不同，IPC对象标识符不是最小整数。当一个IPC对象被创建，以后又被销毁时，与该类型对象相关的标识符会持续加1，直至达到一个整型数的
     最大正值，然后又回转到0
    ●标识符是IPC对象的内部名。为了使多个合作进程能够在同一个IPC对象上会合，需要提供一个外部名方案。为此使用了键，每个IPC对象都与一个键相关联，
     于是键就被作为该对象的外部名
    ●无论何时，创建或者获取一个IPC对象都必须指定一个键。键的数据类型为key_t，在<sys/types.h>头文件中被定义为int。系统内核负责维护键与
     标识符的对应关系
     笔记：
        1、IPC对象是进程间通信的另一种方式。包括共享内存、消息队列、信号量,统称IPC。进程间要通信，首先要创建共享内存、消息队列、信号量。
         创建之后怎么表示它呢？怎么去用它呢？给所创建出来的共享内存、消息队列、信号量指定一个标识符号，也是所谓的编号，
         这个编号跟进程id一个意思。通过编号来表示所创建出来的共享内存、消息队列、信号量。
        2、新的ipc标识符号ID会从0-255依次使用，到末尾后，  又重新返回0；键，目的是让通信双方找到ipc对象。不同的ipc对象有不同的键。
         键是ipc对象的外部名称，ipc对象和键是绑定的。标识符ID是ipc对象的内部名称。进程通过键才能拿到ipc对象的标识符ID。

    #include <sys/ipc.h>
    key_t ftok (const char* pathname, int proj_id);
        功能:用于合成一个键
        参数:pathname：一个真实存在的路径名
            proj_id:项目ID，仅低8位有效，取0到255之间的数
        返回值:成功返回可用于创建或获取IPC对象的键，失败返回-1
    
    ●ftok函数用pathname参数调用stat函数，将其输出的stat结构体中的st_dev(设备ID)和st_ino(i节点号)成员与proj_id参数组合来生成键
        ➢参与生成键的是设备ID和i节点号，而不是pathname参数字符串本身。假设当前路径为/home/tarena/unixc，
         则ftok ("/home/tarena/unixc",123);与 ftok (".",123);所返回的键是完全一样的
    ●设备ID和i节点号都至少是整型字长的数据，而键也是整型字长，再加上一个字节项目ID，在合成键的过程中难免会丢失一部分信息。因此有时候明明
     提供的是不同的路径，该函数返回的键却是一样的
    笔记：
         1、怎么合成键？pathname：必须是真实存在的路径。目的是要的不是串的本身，要是的串本身所表示的文件的元数据，元数据里面有st_dev（设备id）、
           st_imod（i节点号），将st_dev（设备id）、st_imod（i节点号）、proj_id 这3个数各取1到2个字节共同拼凑出来的。3个int，各取1到2个字节，
           凑出4个字节的键。
         2、只要通信双方约定好路径和整数，拿到的键就是一样的。
         3、有没有可能给的路径不同，整数不同，合成的键是相同的呢？有可能，在合成键的时候仅仅是拿3个成员的部分内容，不是全部内容。
           例如：路径一样，整数给44或300，合成的键是一样的。

     
共享内存
    ●两个或者更多进程，共享同一块由系统内核负责维护的内存区域，其地址空间通常被映射到堆和栈之间
    ●多个进程通过共享内存通信，所传输的数据通过各个进程的虚拟内存被直接反映到同一块物理内存中，这就避免了在不同进程和系统内核之间来回复制数据的开销。
      因此基于共享内存的进程间通信，是速度最快的进程间通信方式。
    ●共享内存本身缺乏足够的同步机制，这就需要程序员编写额外的代码来实现

    #include <sys/shm.h>
    int shmget(key_t key, size_t size, int shmflg);
        功能:创建新的或获取已有的共享内存
        参数:key:键。
            shmflg:创建标志，可取以下值:
            size:字节数，自动按页取整。
                    0 - 获取，不存在即失败。
                    IPC_CREAT-创建，不存在即创建，已存在即获取。
                    IPC_EXCL-排它，不存在即创建，已存在即失败。
                    通过位或组合读写权限。
        返回值:成功返回共享内存的ID，失败返回-1。
        笔记：1、Share merge get 获取或创建共享内存
            2、IPC_CREAT ｜ IPC_EXCL 一起使用的意思：不存在则创建，存在则失败。


    //共享内存与虚拟地址进行映射。
    #include < sys/shm.h>
    void* shmat(int shmid, void const* shmaddr, int shmflg);
        功能:加载共享内存，将物理内存中的共享区域映射到进程用户空间的虚拟内存中。
        参数: shmid:共享内存的ID。
             shmaddr:映射到共享内存的虚拟内存起始地址，取NULL，由系统自动选择。
             shmflg:加载标志，可取以下值:
                    0 -以读写方式使用共享。
                    SHM_RDONLY -以只读方式使用共享内存。
        返回值:成功返回共享内存的起始地址，失败返回-1。
        

    ●shmat函数负责将给定共享内存映射到调用进程的虚拟内存空间，返回映射区的起始地址，同时将系统内核中共享内存对象的加载计数加一
    ●调用进程在获得shmat函数返回的共享内存起始地址以后，就可以像访问普通内存一样访问共享内存中数据。

    //解除映射关系
    #include <sys/shm.h>
    int shmdt(void const* shmaddr);
        功能:卸载共享内存
        参数:shmaddr:共享内存的起始地址
        返回值:成功返回0，失败返回-1。
        shmdt函数负责从调用进程的虚拟内存中结束shmaddr所指向的映射区到共享内存的映射，同时将系统内核中共享内存的加载计数减1。


    #include <sys/shm.h>
    int shmctl(int shmid, IPC_RMID, NULL);
        功能:销毁共享内存
        参数:shmid:共享内存对象ID
        返回值:成功返回0，失败返回-1.
        销毁共享内存。其实并非真的销毁，而只是做一个销毁标记，禁止任何进程对该共享内存形成新的加载，但已有的加载依然保留。
          只有当其使用者们纷纷卸载，直至其加载计数降为0时，共享内存才会真的被销毁

    ●基于共享内存实现进程间通信的编程模型
        步骤    进程A        函数                 进程B        步骤
        1    创建共享内存    shmget               获取共享内存    1
        2    加载共享内存    shmat                加载共享内存    2
        3    使用共享内存    strcpy/printf/...    使用共享内存    3
        4    卸载共享内存    shmdt                卸载共享内存    4
        5    销毁共享内存    shmctl               ————          ————

    笔记：
    1、多个进程同时往共享内存中写，就会乱套，这就需要在写代码中花心思。使用共享内存需要注意的问题。
    2、共享内存与虚拟地址进行映射。
    3、加载计数变量是啥我也不知道。它实时记录了有多少个进程与共享内存进行了映射。这个变量由内核来控制的。
    4、ipcs查看共享内存的，状态：多少个进程映射到共享内存
    5、共享内存不手动销毁，就会一直存在。文件打开后如果不关闭，如果忘记关了，在程序结束后就会关闭文件。共享内存如果不手动关闭，在程序结束后不会销毁。
    6、当所有进程不用共享内存了，都解除映射了，才真正的被销毁。
