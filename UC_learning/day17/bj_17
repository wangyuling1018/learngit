 设置掩码与检测未决
     # include <signal.h>
     int sigprocmask (int how, const sigset_t* sigset,sigset_t* oldset);
         功能:设置调用进程的信号掩码
         参数:how:修改信号掩码的方式，可取以下值
                 SIG_BLOCK-将sigset中的信号加入当前信号掩码
                 SIG_UNBLOCK-从当前信号掩码中删除sigset中的信号
                 SIG_SETMASK-把sigset设置成当前信号掩码
             sigset:信号集，取NULL则忽略此参数
             oldset:输出原信号掩码，取NULL则忽略此参数
         返回值:成功返回0，失败返回-1
     例子:
     sigset_t sigset;
     sigemptyset (&sigset);
     sigaddset (&sigset, SIGINT);
     sigaddset (&sigset, SIGQUIT);
     sigset_t oldset;
     if (sigprocmask (SIG_SETMASK, &sigset,&oldset)==-1){
         perror ("sigprocmask");
         exit (EXIT FAILURE);
     }

     #include < siqnal.h>
     int sigpending (sigset_ t* sigset);
         功能:获取调用进程的未决信号集
         参数: sigset: 输出未决信号集
         返回值:成功返回0，失败返回-1
     例子:
         sigset_t sigset;
         if(sigpending (&sigset) ==-1){
             perror("sigpending");
             exit(EXIT_FAILURE);
         }
         if(sigismember(&sigset, SIGINT) == 1){
             printf("SIGINT信号未决\n");
         }

 可靠和不可靠信号的屏蔽
     ●对于可靠信号，通过sigprocmask函数设置信号掩码以后，每种被屏蔽信号中的每个信号都会被阻塞，
      并按先后顺序排队，一旦解除屏蔽，这些信号会被依次递送
     ●对于不可靠信号，通过sigprocmask函数设置信号掩码以后，每种被屏蔽信号中只有第一个会被阻塞，
      并在解除屏蔽后被递送，其余的则全部丢失
 笔记：
     1、信号屏蔽：信号来了，等一会，进程忙完，再处理该信号
     2、信号忽略：信号来了，等一会，进程忙完，找不到该信号了，也就处理不了该信号
     3、有5个17号信号每秒中来一个，当第一个17信号正在处理，此时信号掩码中有17号信号（17号信号被进程屏蔽），当第一个信号处理完后，
       17号信号就从信号掩码中删除了（17号信号屏蔽被解除了），此时有4个17信号正在等待被处理，正在等待被处理的4个信号，
       只处理1个（17号信号又被加入信号掩码中），丢3个。 --- 17信号是不可靠信号
       
进程间通信
何为进程间通信
    ●正如前文所述，Unix/Linux系统中的每个进程都拥有4G字节大小专属于自己的虚拟内存空间，除去内核空间的1G以外，
    每个进程都有一-张独立的内存映射表(又名内存分页表)记录着虚拟内存页和物理内存页之间的映射关系
    ●同一个虚拟内存地址，在不同的进程中，会被映射到完全不同的物理内存区域，因此在多个进程之间以交换虚拟内存地址的
    方式交换数据是不可能的
    ●鉴于进程之间天然存在的内存壁垒，要想实现多个进程间的数据交换，就必须提供一种专门的机制，
    这就是所谓的进程间通信(InterProcess Communication,IPC)
 
进程间通信的种类
    ● 命令行参数
        ➢在通过exec函数创建新进程时，可以为其指定命令行参数，借助命令行参数可以将创建者进程的某些数据传入新进程
        ➢execl ("login","login","username","password", NULL);

    ● 环境变量
        ➢类似地，也可以在调用exec函数时为新进程提供环境变量
        ➢sprintf (envp[0], "USERNAME=%s", username);
        ➢sprintf (envp[1], "PASSWORD=%s", password);
        ➢execle ("login", "login", NULL, envp);
    ● 内存映射文件
        ➢通信双方分别将自己的一段虚拟内存映射到同一个文件中
    ● 信号
        ➢sigaction/sigqueue
    ● 管道
        ➢管道是Unix系统中最古老的进程间通信方式，并且所有的Unix系统和包括Linux系统在内的各种类Unix系统也都提供这种进程间通信机制。管道有两种限制
            管道都是半双工的，数据只能沿着一个方向流动
            管道只能在具有公共祖先的进程之间使用。通常一个管道由一个进程创建，然后该进程通过fork函数创建子进程，父子进程之间通过管道交换数据
        ➢大多数Unix/Linux系统除了提供传统意义上的无名管道以外，还提供有名管道，对后者而言第二种限制已不复存在
    ● 共享内存
        ➢共享内存允许两个或两个以上的进程共享同一块给定的内存区域。因为数据不需要在通信诸方之间来回复制，所以这是速度最快的一种进程间通信方式
    ● 消息队列
        ➢消息队列是由系统内核负责维护并可在多个进程之间共享存取的消息链表。它的优点是: 传输可靠、流量受控、面向有结构的记录、支持按类型过滤
    ● 信号量
        ➢与共享内存和消息队列不同，信号量并不是为了解决进程间的数据交换问题。它所关注的是有限的资源如何在无限的用户间合理分配，即资源竞争问题
    ● 本地套接字
        ➢BSD版本的有名管道。编程模型和网络通信统一。

    笔记：
    1、有名管道：用于任意两个进程通信。
    2、无名管道：用于父子进程、兄弟进程间的通信。
    

有名管道
    ● 有名管道亦称FIFO,是一种特殊的文件，它的路径名存在于文件系统中。通过mkfifo命令可以创建管道文件
        ➢$ mkfifo myfifo
    ● 即使是毫无亲缘关系的进程，也可以通过管道文件通信
        ➢$ echo 'Hello, FIFO !' > myfifo    //一个窗口，echo进程向myfifo写数据
        ➢$ cat myfifo                       //一个窗口，cat进程从myfifo读数据
        ➢Hello, FIFO !
    ● 管道文件在磁盘上只有节点没有数据块，也不保存数据  //ls -l，查看myfifo管道文件的大小为0
    ● 基于有名管道实现进程间通信的逻辑模型
    ● 有名管道不仅可以用于Shell命令，也可以在代码中使用基于有名管道实现进程间通信的编程模型
            步骤    进程A    函数          进程B    步骤
            1    创建管道    mkfifo       ————    ———
            2    打开管道    open         打开管道    1
            3    读写管道    read/write   读写管道    2
            4    关闭管道    close        关闭管道    3
            5    删除管道    unlink        ————    ——
            
    #include <sys/stat.h>
    int mkfifo(char const* pathname, mode_t mode);
    功能:创建有名管道
    参数:pathname:有名管道名，即管道文件的路径。
        mode:权限模式。
    返回值:成功返回0，失败返回-1
    
    笔记：
        1、FIFO：first in first out先进先出
        2、管道文件：是内核维护的缓冲区，通过管道文件找到的是内核的缓冲区，它存在的意义是传递数据，不是存储数据。
        3、有名管道：借助文件系统，生成一个假文件（管道文件 == 内核缓冲区），只要任意的2个进程能拿到这个管道文件，就能进行通信
        4、有名管道借助文件名表示管道的
        
  
无名管道
    ● 无名管道是一一个与文件系统无关的内核对象，主要用于父子进程之间的通信, 需要用专门的系统调用函数创建
    #include < unistd.h>
    int pipe(int pipefd[2]);
        ➢功能:创建无名管道
        ➢参数: pipefd 输出两个文件描述符:
                pipefd[0] -用于从无名管道中读取数据;
                pipefd[1] -用于向无名管道中写入数据。
        ➢返回值:成功返回0，失败返回-1
    笔记：pipe做了2件事情：1、创建了管道。2、将读端描述符存入pipefd[0]中，将写端描述符存入pipefd[1]中

    ● 基于无名管道实现进程间通信的编程模型
        ➢1.父进程调用pipe函数在系统内核中创建无名管道对象，并通过该函数的输出参数pipefd，获得分别用于读写该管道的两个文件描述符pipefd[0]和pipefd[1]
        ➢2.父进程调用fork函数，创建子进程。子进程复制父进程的文件描述符表，因此子进程同样持有分别用于读写该管道的两个文件描述符pipefd[0]和pipefd[1]
        ➢3. 负责写数据的进程关闭无名管道对象的读端文件描述符pipefd[0]，而负责读数据的进程则关闭该管道的写端文件描述符pipefd[1]
        ➢4.父子进程通过无名管道对象以半双工的方式传输数据。如果需要在父子进程间实现双向通信，较一般化的做法是创建两个管道，一个从父流向子，一个从子流向父
        ➢5.父子进程分别关闭自己所持有的写端或读端文件描述符。在与一一个无名管道对象相关联的所有文件描述符都被关闭以后，该无名管道对象即从系统内核中被销毁


    ● 特殊情况
        ●1、从写端已被关闭的管道读取，只要管道中还有数据，依然可以被正常读取，一直到管道中没有数据了，这时read函数会返回0(既不是返回-1，也不是阻塞)，指示读到文件尾。
        ●2、向读端已被关闭的管道写入会直接触发SIGPIPE(13)信号。该信号的默认操作时终止执行写入动作的进程。但如果执行写入动作的进程事先已将对SIGPIPE(13)信号的处理设置为忽略或捕获，则write函数会返回-1, 并置errno为EPIPE。
        ●3、 系统内核通常为每个管道维护一一个大小为4096字节的内存缓冲区。如果写管道时发现缓冲区的空闲空间不足以容纳此次write
            所要写入的字节，则write会阻塞，直到缓冲区的空闲空间变得足够大为止。
        ●读取一个写端处于开放状态的空管道，将直接导致read函数阻塞。 //意思是：写端的描述符没有关，就是有进程用着写端，这个时候去读，就会导致read函数等待，即read函数阻塞。
    笔记：
        1、无名管道：本质也是内核维护的内存缓冲区，只是借助文件描述符（读端描述符和写端描述符）去表示这块内存缓冲区（管道）。
        4、不用的写端或读端，不用就要立即关闭。否则就会阻塞。只要有进程没有关闭写端，表示写端还在用着，还在被占用着，
        read函数处于阻塞状态。
        5、写端的描述符没有关，就是有进程用着写端，这个时候去读，就会导致read函数等待，即read函数阻塞。

管道符号
    ● Unix/Linux系统中的多数Shell环境都支持通过管道符号“|"将前一个命令的输出作为后一个命令的输入的用法
        $ Is -I /etc | more
        $ifconfig | grep inet  //ifconfig输出的内容给grep，grep过滤net
    ● 系统管理员经常使用这种方法，把多个简单的命令连接成一条工具链，去解决一些通常看来可能很复杂的问题
            命令1|命令2|命令3     //命令1输出的内容给命令2，命令2输出的内容给命令3
    ● 假设用户输入如下命令:a|b
        ➢Shell进程调用fork函数创建子进程A
        ➢子进程A调用pipe函数创建无名管道，而后执行
            dup2(pipefd[1],STDOUT_FILENO);
        ➢子进程A调用fork函数创建子进程B，子进程B执行
            dup2(pipefd[0],STDIN_FILENO)
        ➢子进程A和子进程B分别调用exec函数创建a、b进程
        ➢a进程所有的输出都通过写端进入管道，而b进程所有的输入则统统来自该管道的读端。 这就是管道符号的工作原理
    笔记：
        1、管道符号的功能：完成2个命令之间的数据传递。
        2、ifconfig与grep之间通过管道符号｜连接起来，它们2个的关系是：输入与输出的关系。原本该ifconfig输出的内容是呈现在屏幕上，
          但是现在用管道符号｜连接下一个命令就变了，ifconfig输出的内容给到了grep命令上，grep命令接收到了ifconfig的输出的内容之后，
          然后去做inet过滤，过滤后的内容呈现在屏幕上。
        3、｜管道符号连接的2个命令起到的效果就是：前面命令执行的输出内容，借助管道符号，传递给后面的命令。起到的效果实际就是传递的功能。

