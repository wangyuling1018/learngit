    思考:以下代码总共产生多少个进程
        for(inti= 0;i < 3;i++){
            fork();
        }
        答案: -共有8个进程
        //第一次循环：父 -》 子1
        //第二次循环：父 -〉 子2；子1 -》 子3
        //第三次循环：父 -〉子4，子2 -》子5； 子1 -〉子6， 子3 -》子7，共计8个进程
        
创建子进程
    ●由fork产生的子进程是其父进程的不完全副本，子进程在内存中的映像除了代码区与父进程共享同-块物理内存，
     其它各区映射到独立的物理内存，但其内容从父进程拷贝。
    ●fork函数返回后，系统内核会将父进程维护的文件描述符表也复制到子进程的进程表项中，但并不复制文件表象。 //意味着：父、子进程可以通过文件描述符访问同一个文件，相互影响文件读写位置
    ●孤儿进程演示
    ●僵尸进程演示

进程终止
正常终止
    1、从main函数中返回可令进程终止
        ➢进程是内存中的代码和数据，而线程则是执行代码的过程。每个进程可以包含一个多个线程，但至少要有一个主线程。每个线程都可以被看做是在一个独立的执行过程中调用了一个特殊的函数，谓之线程过程函数。线程开始，线程过程函数即被调用，线程过程函数一旦返回，线程即告终止。因此main函数也可以被看做是进程的主线程的线程过程函数。main函数一旦返回，主线程即终止，进程即终止，进程一旦终止，进程中的所有线程统统终止。这就是main函数的返回与其它函数的返回在本质上的区别。
        ➢main函数的返回值即进程的退出码，父进程可以在回收子进程的同时获得该退出码，以了解导致其终止的具体原因。
    2、调用exit函数令进程终止
        #include <stdlib.h>
        void exit(int status);
            功能:令进程终止
            参数: status进程的退出码，相当于main函数的返回值该函数不返回! ! !
        ➢虽然exit函数的参数和main函数的返回值都是int类型，但只有其中最低数位的字节可被其父进程回收，高三个字节会被忽略，
             因此在设计进程的退出码时最好不要超过一字节的值域范围
        ➢通过return语句终止进程只能在main函数中实现，但是调用exit函数终止进程可以在包括main函数在内的任何函数中使用。
        ➢exit函数在终止调用进程之前还会做几件收尾工作
            A、调用实现通过atexit或on_exit函数注册的退出处理函数;
            B、冲刷并关闭所有仍处于打开状态的标准I/O流;  //如果缓冲区有数据，则将缓冲区的数据输出到屏幕
            C、删除所有通过tmpfile函数创建的临时文件;
            D、exit(status);
            //缓冲区输出到屏幕的3个条件：有\n,缓冲区满，程序结束，满足一个即可。
            
        ➢习惯上，还经常使用EXIT_SUCCESS和EXIT_FAILURE两个宏作为调用exit函数的参数，分别表示成功和失败。
             它们的值在多数系统中被定义成0和-1，但一般建议使用宏，这样做兼容性更好

        注册退出处理函数
        #include <stdlib.h>
        int atexit (void (*function) (void));   //先左后右，由近及远，括号优先
            参数:function 函数指针，指向退出处理函数
            返回值:成功返回0,失败返回-1
        ➢注意atexit函数本身并不调用退出处理函数，而只是将function参数所表示的退出处理函数地址，保存(注册)在系统内核的
        某个地方(进程表项)。待到exit函数被调用或在main函数里执行return语句时，再由系统内核根据这些退出处理函数的地址来调用它们。此过程亦称回调
        //把哪个函数地址给atexit函数，就会把这个函数注册成退出处理函数
        
        #include <stdlib.h>
        int on_exit(void(*function)(int，void*),void*arg);
            参数:function 函数指针，指向退出处理函数。其中第一个参数来自传递给exit函数的status参数或在main函数里
                             执行return语句的返回值，而第二个参数则来自传递给on_exit函数的arg参数
                arg 泛型指针，将作为第二个参数传递给function所指向的退出处理函数
            返回值:成功返回0,失败返回-1
        //atexit函数和on_exit功能相同，区别：atexit不可以传参数，on_exit可以传参数，做最后的收尾工作。


    3、调用_exit/_Exit函数令进程终止
        #include <unistd.h>
        void exit(int status);
            参数:status进程退出码，相当于main函数的返回值该函数不返回!
        #include <stdlib.h>
        void Exit(int status);
            参数:status 进程退出码，相当于main函数的返回值该函数不返回!

        ➢_exit在终止调用进程之前也会做几件收尾工作，但与exit函数所做的不同。事实上，exit 函数在做完它那三件收尾工作
        之后紧接着就会调用_exit函数
            A、关闭所有仍处于打开状态的文件描述符
            B、将调用进程的所有子进程托付给init进程收养
            C、向调用进程的父进程发送SIGCHLD(17)信号
            D、令调用进程终止运行，将status的低八位作为退出码保存在其终止状态中
                
    笔记：
        init是1号进程，也叫孤儿院进程。不同的系统1号进程扮演不同的角色。
        正常终止，进行以下一系列的收尾工作，如所示：
        A、调用实现通过atexit或on_exit函数注册的退出处理函数;
        B、冲刷并关闭所有仍处于打开状态的标准I/0流;
        C、删除所有通过tmpfile函数创建的临时文件;
        D、_exit(status)：
            A. 关闭所有仍处打开状态的文件描述符
            B、将调用进程的所有子进程托付给init进程收养
            C、向调用进程的父进程发送SIGCHLD(17)信号
            D、令调用进程终止运行，将status的低八位作为退出码保存在其终止状态中
        终止状态是一个int整数，子进程在内存中所占的资源(4个字节)就是终止状态，也就是尸体
        注册函数可以有多个，注册的顺序和执行的顺序是相反的
        系统可以直接调用_exit或_Exit。也算正常终止


异常终止
    1、当进程执行了某些在系统看来具有危险性的操作，或系统本身发生了某种故障或意外，内核会向相关进程发送
    特定的信号。如果进程无意针对收到的信号采取补救措施，那么内核将按照缺省方式将进程杀死，并视情形生
    成核心转储文件(core)以备事后分析，俗称吐核
        SIGILL(4):进程试图执行非法指令
        SIGBUS(7):硬件或对齐错误
        SIGFPE(8):浮点异常
        SIGSEGV(11):无效内存访问
        SIGPWR(30):系统供电不足
    
    笔记：做了一些操作系统忍受不了事情，操作系统直接结束掉进程。------------简称：作死。

    2、人为触发信号
        SIGINT(2):Ctrl+C
        SIGQUIT(3):Ctrl+\
        SIGKILL(9):不能被捕获或忽略的进程终止信号
        SIGTERM(15):可以被捕获或忽略的进程终止信号
        
    笔记：例如死循环，无法退出程序，按ctrl + c 键强制退出程序。---------------简称：他杀。

    3、向进程自己发送信号
        #include <stdlib.h>
        void abort(void);
            功能:向调用进程发送SIGABRT(6)信号,该信号默认情况下可使进程结束无参数，不返回!
            
    笔记：自己给自己发一个信号，自己给自己干死了。-------简称：自杀。
        调用abort函数，进程是被6信号杀死了
        
       
