    3、调用_exit/_Exit函数令进程终止
        #include <unistd.h>
        void exit(int status);
            参数:status进程退出码，相当于main函数的返回值该函数不返回!
        #include <stdlib.h>
        void Exit(int status);
            参数:status 进程退出码，相当于main函数的返回值该函数不返回!

        ➢_exit在终止调用进程之前也会做几件收尾工作，但与exit函数所做的不同。事实上，exit 函数在做完它那三件收尾工作
        之后紧接着就会调用_exit函数
            A、关闭所有仍处于打开状态的文件描述符
            B、将调用进程的所有子进程托付给init进程收养
            C、向调用进程的父进程发送SIGCHLD(17)信号
            D、令调用进程终止运行，将status的低八位作为退出码保存在其终止状态中
                
    笔记：
        init是1号进程，也叫孤儿院进程。不同的系统1号进程扮演不同的角色。
        正常终止，进行以下一系列的收尾工作，如所示：
        A、调用实现通过atexit或on_exit函数注册的退出处理函数;
        B、冲刷并关闭所有仍处于打开状态的标准I/0流;
        C、删除所有通过tmpfile函数创建的临时文件;
        D、_exit(status)：
            A. 关闭所有仍处打开状态的文件描述符
            B、将调用进程的所有子进程托付给init进程收养
            C、向调用进程的父进程发送SIGCHLD(17)信号
            D、令调用进程终止运行，将status的低八位作为退出码保存在其终止状态中
        终止状态是一个int整数，子进程在内存中所占的资源(4个字节)就是终止状态，也就是尸体
        注册函数可以有多个，注册的顺序和执行的顺序是相反的
        系统可以直接调用_exit或_Exit。也算正常终止


异常终止
    1、当进程执行了某些在系统看来具有危险性的操作，或系统本身发生了某种故障或意外，内核会向相关进程发送
    特定的信号。如果进程无意针对收到的信号采取补救措施，那么内核将按照缺省方式将进程杀死，并视情形生
    成核心转储文件(core)以备事后分析，俗称吐核
        SIGILL(4):进程试图执行非法指令
        SIGBUS(7):硬件或对齐错误
        SIGFPE(8):浮点异常
        SIGSEGV(11):无效内存访问 //段错误，核心已转储
        SIGPWR(30):系统供电不足
    
    笔记：做了一些操作系统忍受不了事情，操作系统直接结束掉进程。------------简称：作死。

    2、人为触发信号
        SIGINT(2):Ctrl+C
        SIGQUIT(3):Ctrl+\
        SIGKILL(9):不能被捕获或忽略的进程终止信号
        SIGTERM(15):可以被捕获或忽略的进程终止信号
        
    笔记：例如死循环，无法退出程序，按ctrl + c 键强制退出程序。-----------简称：他杀。

    3、向进程自己发送信号
        #include <stdlib.h>
        void abort(void);
            功能:向调用进程发送SIGABRT(6)信号,该信号默认情况下可使进程结束.无参数，不返回!
            
    笔记：自己给自己发一个信号，自己给自己干死了。-------简称：自杀。
        调用abort函数，进程是被6信号杀死了
        
       

为什么要回收子进程
    ●清除僵尸进程，避免消耗系统资源。
    ●父进程需要等待子进程的终止，以继续后续工作。
    ●父进程需要知道子进程终止的原因
        如果是正常终止，那么进程的退出码是多少?
        如果是异常终止，那么进程是被那个信号所终止的?
    笔记：
    为什么要回收子进程
        1、程序结束之后，如果没有及时收尸的话，我的进程仍然在内存中占着一部分资源。一个进程占的空间不多，
        资源不多，如果非常多非常多的僵尸不被收尸，内存会被沾满，系统就会很卡了。
        2、某些场景下，父进程要继续执行，需要等到子进程某些功能执行完成后，父进程才能继续执行。
        子进程完成后，父进程收完子进程的尸体后才能继续执行。


wait
    #include <sys/wait.h>
    pid_t wait(int* status);  //阻塞函数
        功能:等待并回收任意子进程 //谁先死就先收谁
        参数:status用于输出子进程的终止状态，可置NULL //status输出型参数，输出子进程的终止状态，NULL表示对应子进程的终止状态不关心
        返回值:成功返回所回收的子进程的PID，失败返回-1
    父进程在创建若干子进程以后调用wait函数:
        ➢A.若所有子进程都在运行，则阻塞，直到有子进程终止才返回;
        ➢B.若有-个子进程已终止，则返回该子进程的PID并通过status参数输出其终止状态;
        ➢C.若没有任何可被等待并回收的子进程,则返回-1,置errno为ECHILD。
    ●在任何一个子进程终止前，wait函数只能阻塞调用进程，如果有一个子进程在wait函数被调用之前，已经终止并处于
     僵尸状态，wait函数会立即返回，并取得该子进程的终止状态，同时子进程僵尸消失。由此可见wait函数主要完成三个任务
        ➢1. 阻塞父进程的运行，直到子进程终止再继续，停等同步
        ➢2. 获取子进程的PID和终止状态，令父进程得知谁因何而死
        ➢3.为子进程收尸，防止大量僵尸进程耗费系统资源
    ●以上三个任务钟，即使前两个与具体需求无关，仅仅第三个也足以凸显wait函数的重要性，尤其是对那些多进程服务
     器型的应用而言
    ●子进程的终止状态通过wait函数的status参数输出给该函数调用者。<sys/wait.h>头文件提供了几个辅助
      分析进程终止状态的工具宏
    ●WIFEXITED(status)
        ➢真:正常终止WEXITSTATUS(status)->进程退出码
        ➢假:异常终止WTERMSIG(status)->终止进程的信号
    ●WIFSIGNALED(status)
        ➢真:异常终止WTERMSIG(status) ->终止进程的信号
        ➢假:正常终止WEXITSTATUS(status) ->进程退出码
    ●事实上，无论一个进程是正常终止还是异常终止，都会通过系统内核向其父进程发送SIGCHLD(17)信号。
     父进程可以忽略该信号，也可以提供一个针对该信号的信号处理函数，在信号处理函数中以异步的方式回收子进程。
     这样做不仅流程简单，而且僵尸的存活时间短，回收效率高

    笔记：
    1、回收任意子进程：谁先死了，就先收谁的尸体。
    2、通过终止状态可以知道进程是怎么死的，是正常死的还是异常的。
    3、int* status是输出型参数。输出型参数：给谁的地址，就把数据输出到谁的里面。wait输出的是你所回收的子进程的终止状态。
     终止状态是一个int整数，子进程在内存中所占的资源(4个字节)就是终止状态，也就是尸体，僵尸。子进程终止时会return 0或
     return -1或exit(0)等，会产生终止状态，其中0、-1是退出码，父进程会拿到这个终止状态。终止状态包含退出码，终止状态是4个字节，
     其中低1个字节是退出码。
    4、如果父进程回收子进程时，不关心子进程的是如何终止的，即不关心子进程的终止状态，那么参数可设置为NULL。
    5、终止状态包含退出码，终止状态4个字节，其中低8位（低1个字节）存的是退出码。
    6、父进程拿到子进程的终止状态后，通过下面几个宏可以知道子进程是如何被终止的。WIFEXITED 、WIFSIGNALED
        

waitpid
    #include <sys/wait.h>
    pid_t waitpid(pid_t pid, int* status, int options);
        功能:等待并回收任意或特定子进程
        参数:pid可以以下取值
                -1 等待并回收任意子进程，相当于wait函数
                >0 等待并回收特定子进程
            status 用于输出子进程的终止状态，可置NULL
            options可以如下取值
                    0  阻塞模式，若所等子进程仍在运行，则阻塞直至其终止。
                    WNOHANG 非阻塞模式，若所等子进程仍在运行，则返回0.
        返回值:成功返回所回收子进程的PID或者0，失败返回-1。
        waitpid(-1,&status,0) 等价于wait(&status);
    笔记：
        1、阻塞方式：子进程没有结束，我就在这儿等，等到子进程结束了，我再回收。
        2、非阻塞方式：子进程没有结束，我就返回0，可以先去干点别的事情，过一会我再回来看看子进程结束了没有，
         结束了我就收，没有结束我再返回0。
