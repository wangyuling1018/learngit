
信号基础

什么是信号
    ➢信号在最早的UNIX系统中即被引入，已有30多年的历史，但只有很小的变化。
    ➢信号是提供异步事件处理机制的软件中断。
    ➢这些异步事件可能来自硬件设备，如用户同时按下了Ctrl键和C键，也可能来自系统内核，如试图访问尚未
     映射的虚拟内存，又或者来自用户进程，如尝试计算整数除以0的表达式
    ➢进程之间可以相互发送信号，这使信号成为一种进程间通信(Inter- ProcessCommunication, IPC)的基本手段
    ➢信号的异步特性不仅表现为它的产生是异步的，对它的处理同样也是异步的。程序的设计者不可能也不需要精确地
     预见什么时候触发什么信号，也同样无法预见该信号究竟在什么时候会被处理。一切都在内核的操控下，异步地运行。
     信号是在软件层面对中断机制的一种模拟
     信号的名称与编号
     
笔记：
    1、中断：中间断开，CPU不处理我当前执行的程序了，去处理其他的事情，处理完成后回来再处理我的。
     被迫停止了，我的程序因为某些原因被迫终止了。
    2、异步：多个事情之间没有关系。信号和程序执行之间没有关系。程序不知道什么时候信号会来。信号会让程序中断。
    3、不同的事件发生会产生不同的信号，不同的信号会对进程产生不同的影响。这些事情可能来自不同的层面。
     硬件层面：ctrl + c，内核层面：去访问没有映射的虚拟地址，程序自身的层面：除以0.
    4、信号是软件层面让程序中断。
    5、信号是进程间的通信手段。对于信号，它可以由某些事件发生产生信号，也可以2个进程之间发送信号。
    6、信号的产生是异步的：程序在运行的过程中什么时候产生信号，什么时候会到来信号，是不确定的，不知道的。
    7、信号的处理也是异步的：信号来了之后，我需要对信号去进行处理，什么时候处理，不知道，不确定。
    8、信号的产生、信号的处理都是在内核的控制下，异步运行。
    9、不可靠信号：是会丢失，

信号的名称与编号
    ➢信号是很短的消息，本质就是一个整数，用以区分代表不同事件的不同信号
    ➢为了便于记忆，在signum.h头文件中用一组名字前缀为SIG的宏来标识信号，即为信号的名字。
    ➢通过kill -l 命令可以查看信号
    ➢一共有62个信号，其中前31个信号为不可靠的非实时信号，后31个为可靠的实时信号

常用信号
    编号   名称        说明                                     默认操作
    1     SIGHUP     进程的控制终端关闭(用户登出)                  终止
    2     SIGINT     用户产生中断符(Ctrl+C)                      终止
    3     SIGQUIT    用户产生退出符(Ctrl+\)                      终止+转储
    4     SIGILL     进程试图执行非法指令                         终止+转储
    5     SIGTRAP    进入断点                                   终止+转储
    6     SIGABRT    abort函数产生                              终止+转储
    7     SIGBUS     硬件或对齐错误                              终止+转储
    8     SIGFPE     算术异常                                   终止+转储
    9     SIGKILL    不能被捕获或忽略的进程终止信号                 终止
    10    SIGUSR1    进程自定义的信号                             终止
    11    SIGSEGV    无效内存访问                                终止+转储
    12    SIGUSR2    进程自定义的信号                             终止
    13    SIGPIPE    向读端已B关闭的管道写入                       终止
    14    SIGALRM    alarm函数产生/真实定时器到期                  终止
    15    SIGTERM    可以被捕获或忽略的进程终止信号                 终止
    16    SIGSTKFLT  协处理器栈错误                              终止
    17    SIGCHLD    子进程终止                                 忽略
    18    SIGCONT    进程由停止状态恢复运行                       忽略
    19    SIGSTOP    不能被捕获或忽略的进程停止信号                 停止
    20    SIGTSTP    用户产生停止符(Ctrl+Z)                      停止
    21    SIGTTIN    后台进程读控制终端                           停止
    22    SIGTTOU    后台进程写控制终端                           停止
    23    SIGURG     紧急I/O未处理                              忽略
    24    SIGXCPU    进程资源超限                               终止+转储
    25    SIGXFSZ    文件资源超                                 终止+转储
    26    SIGVTALRM  虚拟定时器到期                              终止
    27    SIGPROF    实用定时器到期                              终止
    28    SIGWINCH   控制终端窗口大小改变                         忽略
    29    SIGIO      异步I/O事件                                终止
    30    SIGPWR     断电                                      终止
    31    SIGSYS     进程试图执行无效系统调用                      终止+转储
    //9和19号信号是必杀信号
    
信号的处理
    忽略:什么也不做，SIGKILL(9)和SIGSTOP(19)不能被忽略
    默认:在没有人为设置的情况，系统缺省的处理行为。
    捕获:接收到信号的进程会暂停执行，转而执行一段事先编写好的处理代码，执行完毕非会员后再从暂停执行的地方继续运行。

    #include <signal.h>
    typedef void(*sighandler_t)(int);
    sighandler_t signal(int signum, sighandler_t handler);
        功能:设置调用进程针对特定信号的处理方式
        参数:signum信号编号
            handler信号的处理方式， 可以如下取值
                SIG_IGN       - 忽略
                SIG_DFL       - 默认
                信号处理函数指针 - 捕获
        返回值:成功返回原信号处理方式，如果之前未处理过则返回NULL，失败返回SIG_ERR。
    笔记：
    1、函数的功能：对那个那个（参数1）信号做什么什么（参数2）处理。参数1是信号，参数2是处理方式。
    2、sighandler_t是函数指针类型。
    3、参数1:可以是数字，也可以是宏。
    4、Typedef void(*sighandler_t)(int);是对sighandler_t的定义。sighandler_t是函数指针的别名。
    5、参数2:传函数的地址。函数是void signal(int)的函数，参数必须是int，返回值必须是void。
    6、SIG_ERR、SIG_DFL 、SIG_IGN这些宏被强转成指针类型的-1、0、1.
    7、返回值：我当前在程序中是不是第一次对2号信号做处理，如果是第一次处理，则返回NULL，如果我在程序中对于2号信号有过多次处理，
      则返回上一次对该信号的处理方式。
    8、实际工作中很少用到signal的返回值，也就不需要去写这条定义Typedef void(*sighandler_t)(int); 笔试和面试的时候会问。
    9、信号处理函数是内核处理的。不是main函数处理的。内核负责传参数，将捕获的信号传递给signum。内核负责处理信号函数，
      内核负责传递信号参数。


信号处理流程
    ●主控制流程、信号处理流程和内核处理流程
        ➢当有信号到来时，内核会保存当前进程的栈帧，然后再执行信号处理函数
        ➢当信号处理函数结束后，内核会恢复之前保存的进程的栈帧，使之继续执行
    笔记：当信号到来时，进程暂停，转而去执行信号处理函数，当信号处理函数执行完后，进程继续执行。




太平间信号
    ●如前所述，无论一个进程是正常终止还是异常终止，都会通过系统内核向其父进程发送SIGCHLD(17)信号。父进程完全可以在针对SIGCHLD(17)信号的信号处理函数中，异步地回收子进程的僵尸，简洁而又高效
        void sigchld (int signum){
            pid_t pid = wait(NULL);
            if (pid == -1){
                perror ("wait");
                exit (EXIT_FAILURE);
            }
            printf ("%d子进程终止\n",pid);
        }

    ●但这样处理存在一一个潜在的风险，就是在sigchld信号处理函数执行过程中，又有多个子进程终止，由于SIGCHLD(17)信号不可靠， 可能会丢失，形成漏网僵尸，因此有必要在一一个循环过程中回收尽可能多的僵尸
        void sigchld (int signum) {
            for (;;) {
                pid_t pid = wait (NULL);
                if(pid == -1){
                    if (errno != ECHILD) {
                        perror ("wait");
                        exit (EXIT_FAILURE);
                        }
                    printf ("子进程都死光了\n"); break;
                }
                printf (" %d子进程终止\n", pid);
            }
        }

    ●但上面的代码同样存在问题，因为当所有的子进程都处于运行状态时wait函数会阻塞,这时sigchld信号处理函数就不会返回，被信号中断的操作也就无法继续。为此，可以考虑用具有非阻塞特性的waitpid函数取代wait函数
        void sigchld (int signum){
                for (;;){
                    pid_t pid = waitpid (-1,NULL, WNOHANG);
                    if (pid==-1){
                        if (errno!= ECHILD){
                            perror ("wait");
                            exit (EXIT_FAILURE);
                        }
                        printf("子进程都死光了\n"); break;
                    }
                    if (!pid) break;
                printf ("%d子进程终止\n",pid);
                }
        }
        笔记：
            1、17号信号就是太平间信号
            2、子进程只要死，就有17号信号到来，主进程就会去收尸，收完尸后主进程继续执行----简洁而又高效
            3、主进程对17号信号进行捕获，不会影响主进程本来的工作，主进程没事的时候就干本来的工作，有事情的时候就去收尸，子进程死会发送17号信号。
            4、在信号处理函数执行其间，如果有相同的信号同一个时间多次到来，只保留1个，其余统统丢弃。
