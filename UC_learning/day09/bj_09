文件锁的内核结构
    ●每次对给定文件的特定区域加锁，都会通过fcntl函数向系统内核传递flock结构体，该结构体中包含了有关锁的一切细节，诸如锁的类型(读锁/写锁)，锁区的起始位置和大小，甚至加锁进程的PID(填-1由系统自动设置)
    ●系统内核会收集所有进程对该文件所加的各种锁，并把这些flock结构体中的信息，以链表的形式组织成一张锁表，而锁表的起始地址就保存在该文件的v节点中
    ●任何一个进程通过fcntl函数对该文件加锁，系统内核都要遍历这张锁表，旦发现有与欲加之锁构成冲突的锁即阻塞或报错，否则即将欲加之锁插入锁表，
     而解锁的过程实际上就是调整或删除锁表中的相应节点

访问测试
    #include <unistd.h>
    int access(char const* pathname, int mode);
        功能:判断当前进程是否可以对某个给定的文件执行某种访问。
        参数:pathname文件路径
            mode 被测试权限，可以以下取值
                R_OK -可读否
                W_OK -可写否
                X_OK -可执行否
                F_OK -存在否
        返回值:成功返回0，失败返回-1。


修改文件大小
    #include <unistd.h>
    int truncate(char const* path, off_t length);
    int ftruncate(int fd,off t length);
        功能:修改指定文件的大小
        参数:path:文件路径
            length:文件大小
            fd:文件描述符
        返回值:成功返回0，失败返回-1。
    该函数既可以把文件截短，也可以把文件加长，所有的改变均发生在文件的尾部，新增加的部分用数字0填充。



文件元数据的获取
    #include <sys/stat.h>
    int stat(char const* path, struct stat* buf);
    int fstat(int fd, struct stat* buf);
    int lstat(char const* path, struct stat* buf);
        功能:从i节点中提取文件的元数据，即文件的属性信息
        参数:path：文件路径
            buf：文件元数据结构 //输出型参数
            fd：文件描述符
        返回值:成功返回0，失败返回-1

文件元数据的获取
    lstat()函数与另外两个函数的区别在于它不跟踪符号链接。
        例:
        abc.txt --->xyz.txt abc.txt文件是xyz.txt文件的符号链接
        stat( “abc.txt”，...);   //得到xyz.txt文件的元数据
        lstat( “abc.txt”，...);  //得到abc.txt文件的元数据
        
文件元数据结构
    ●stat函数族通过stat结构体，向调用者输出文件的元数据
        struct stat{
            dev_t st_dev;        //设备ID
            ino_t st_ino;        //i节点号
            mode_t st_mode;      //文件的类型和权限 //unsigned int: 4字节
            nlink_t st_nlink;    //硬链接数
            uid_t st_uid;        //拥有者用户ID
            gid_t st_gid;        // 拥有者组ID
            dev_t st_rdev;       //特殊设备ID
            off_t st_size;       //总字节数
            blksize_t st_blksize;//I/O块字节数
            blkcnt_t st_blocks;  //存储块数time_t
            time_t st_atime,     //最后访问时间
            time_t st_mtime;     //最后修改时间
            time_t st_ctime;     // 最后状态改变时间
            }

    ●stat结构的st_mode成员表示文件的类型和权限，该成员在stat结构中被声明为mode谈型，其原始类型在32位系统中被定义
     为unsigned int,即32位无符号整数，但到目前为止，只有其中的低16位有意义
    ●用16位二进制数(B15..B0)表示的文件类型和权限，从高到低可被分为五组
        ➢B15 - B12:文件类型
        ➢B11 - B9 :设置用户ID，设置组ID,粘滞
        ➢B8 -  B6 :拥有者用户的读、写和执行权限
        ➢B5 -  B3 :拥有者组的读、写和执行权限
        ➢B2 -  BO :其它用户的读、写和执行权限
        
    文件类型:B15-B12
        
    设置用户ID、设置组ID和粘滞:B11-B9
        ➢系统中的每个进程其实都有两个用户ID, -一个叫实际用户ID, -一个叫有效用户ID
        ➢进程的实际用户ID继承自其父进程的实际用户ID。当一个用户通过合法的用户名和口令登录系统以后，系统就会为他启动一个Shell进程，
         Shell进程的实际用户ID就是该登录用户的用户ID。该用户在Shell下启动的任何进程都是Shell进程的子进程，自然也就继承了Shell进程的实际用户ID
        ➢一个进程的用户身份决定了它可以访问哪些资源，比如读、写或者执行某个文件。但真正被用于权限验证的并不是进程的实际用户ID，而是其有效用户ID。
            一般情况下，进程的有效用户ID就取自其实际用户ID，可以认为二者是等价的
        ➢但是，如果用于启动该进程的可执行文件带有设置用户ID位，即B11位为1，那么该进程的有效用户ID就不再取自其实际用户ID，而是取自可执行文件的
          拥有者用户ID
        ➢系统管理员常用这种方法提升普通用户的权限，让他们有能力去完成一些本来只有root用户才能完成的任务。例如，他可以为某个拥有者用户为root的可
         执行文件添加设置用户ID位，这样一来无论运行这个可执行文件的实际用户是谁，启动起来的进程的有效用户ID都是root，凡是root用户可以访问的资源，
         该进程都可以访问。当然，具体访问哪些资源以何种方式访问，还要由这个可执行文件的代码来决定。作为一个安全的操作系统，不可能允许一个低权限用户
         在高权限状态下为所欲为。如通过passwd命令修改口令
        ➢带有设置用户ID位的不可执行文件:没有意义。
        ➢带有设置用户ID位的目录文件:没有意义。
        ➢与设置用户ID位的情况类似，如果一个可执行文件带有设置组ID位，即B10位为1，那么运行该可执行文件所得到的进程，它的有效组ID同样不取自其实际组ID，
         而是取自可执行文件的拥有者组ID
        ➢带有设置组ID位的不可执行文件:某些系统上用这种无意义的组合表示强制锁。
        ➢带有设置组ID位的目录文件:在该目录下创建文件或子目录，其拥有者组取自该目录的拥有者组，而非创建者用户所隶属的组。
        ➢带有粘滞位(B9)的可执行文件，在其首次运行并结束后， 其代码区被连续地保存在磁盘交换区中，而一般磁盘文件的数据块是离散存放的。因此，‘ 下次运行该程序可以获得较快的载入速度
        ➢带有粘滞位(B9)的不可执行文件:没有任何意义
        ➢带有粘滞位(B9)的目录: 除root以外的任何用户在该目录下，都只能删除或者更名那些属于自己的文件或子目录，而对于其它用户的文件或子目录，
         既不能删除也不能改名，如/tmp月录  //只能改自己的东西，不能改别人的东西
    笔记：
        a.out（拥有者root） -> ./a.out进程 ->实际用户ID 取决于 登录身份 terana
                                        ->有效用户ID ->一般 b11=0， 取决于 登录身份 terana
                                                    ->特殊 b11=1，取决于， 形成该进程的可执行文件a.out,如果a.out拥有设置用户ID位，那么有效用户ID取决于a.out的拥有者
            有效用户ID决定当前进程使用系统资源的能力，
            如果进程的有效用户ID是root，那么进程访问系统的资源就是root的权限，
            如果进程的有效用户ID是terana，那么进程访问系统的资源就是terana的权限。
            root的权限最高，可以访问系统所有资源。
            可执行文件才有进程，进程才有有效用户ID，目录、文件是不可执行文件，拥有设置组ID位没有意义
         
    拥有者用户的读、写和执行权限:B8-B6
    拥有者组的读、写和执行权限: B5 -B3
    其他用户的读、写和执行权限: B2 -B0

    辅助分析文件类型的实用宏
        ➢S_ISREG()  :是否普通文件
        ➢S_ISDIR()  :是否目录
        ➢S_ISSOCK() :是否本地套接字
        ➢S_ISCHR()  :是否字符设备
        ➢S_ISBLK()  :是否块设备
        ➢S_ISLNK()  :是否符号链接
        ➢S_ISFIFO() :是否有名管道
        
内存映射文件
    #include <sys/mman.h>
    void* mmap(void* start, size t length, int prot, int flags,int fd, off t offset);
        功能:建立虚拟内存到物理内存或磁盘文件的映射:
        参数:start:映射区虚拟内存的起始地址，NULL系统自动选定后返回。
            length:映射区字节数，自动按页圆整。
            prot:映射区操作权限，可取以下值:
                PROT_READ-映射区可读
                PROT_WRITE-映射区可写
                PROT_EXEC-映射区可执行
                PROT_NONE-映射区不可访问
            lags:映射标志，可取以下值:
                MAP_ANONYMOUS -匿名映射，将虚拟内存映射到物理内存而非文件，忽略fd和offset参数
                MAP_PRIVATE -对映射区的写操作只反映到缓冲区中并不会真正写入文件
                MAP_SHARED -对映射区的写操作直接反映到文件中
                MAP_DENYWRITE -拒绝其它对文件的写操作
                MAP_FIXED -若在start上无法创建映射，则失败(无此标志系统会自动调整)
            fd:文件描述符
            offset:文件偏移量，自动按页(4K)对齐
        返回值:成功返回映射区虚拟内存的起始地址，失败返回MAP FAILED(-1)。
        
解除内存映射
    # include <sys/mman.h>
    int munmap(void* start, size_t length);
        功能:解除虚拟内存到物理内存或磁盘文件的映射:
        参数:start:映射区虚拟内存的起始地址。
            length:映射区字节数，自动按页圆整。
        返回值:成功返回0，失败返回-1。
    munmap允许对映射区的一部分解映射，但必须按页处理












