今天晚上 + 后天晚上
周六 - 8月20号 - 晚上 - 张超 - Linux下C编程

今日内容:
一.4个排序算法
1.冒泡排序
    数据冒泡
    核心思想就是将无序表中的所有数据, 进行两两比较, 得到升序序列 或者 降序的序列
        升序 - 数据在不断的变大
        降序 - 数据在不断的变小
    举例 :
    将数据从小到大排序 - 先获取到了最大值, 然后将最大值放到了最右边
    初始状态数据 : 9 7 5 3 1
    第一趟 :  7 5 3 1 9 (4次)  //9分别和7 5 3 1比
    第二趟 :  5 3 1 7 9 (4次） //7分别和5 3 1 9比
    第三趟 :  3 1 5 7 9 (4次)  //5分别和3 1 7 9比
    第四趟 :  1 3 5 7 9 (4次)  //3分别和1 5 7 9比
    目前 - n个数据必须 n-1 趟排序, 每趟需要 n-1 次比较

    优化1 :
    初始状态数据 : 9 7 5 3 1
            9 7 5 3 1
    第一趟 : 7 5 3 1 9 (4次) n - 1    //9分别和7 5 3 1比
    第二趟 : 5 3 1 7 9 (3次) n - 2    //7分别和5 3 1 比
    第三趟 : 3 1 5 7 9 (2次) n - 3    //5分别和3 1 比
    第四趟 : 1 3 5 7 8 (1次) n - 4    //3分别和1比
    目前 - n个数据需要 n-1 趟排序, 每趟需要 n-i 次.

    优化2 :
    初始状态数据 : 0 7 5 3 1
            0 7 5 3 1
    第一趟:  0 5 3 1 7 (4次)
    第二趟:  0 3 1 5 7 (3次)
    第三趟:  0 1 3 5 7 (2次)
    ------------------------
    第四趟:  0 1 3 5 7 (1次)
    分析 :
        第三趟排序结束之后, 已经是从小到大的顺序排列了 - 就可以不比第四趟了
    
    判断 - 如果已经是从小到大的顺序了, 我们就不再比较了

    结论 :
        如果拿到的一堆数据, 发现没有发生数据的交换, 则认为排序完成

    假设 : 0 3 5 9 11
    如果拿到的数据 - 天然有序 - 不需要排序

    添加判断条件 :
        判断什么时候这一堆数据已经有序了 - 不再继续排序

    如果某一趟 - 没有发生数据交换 - 排序完成

    
    
2.插入排序算法
    初始状态 : 10 30 20 15 60
    思路 :
        定义一个变量暂存要插入到的数据, 然后 [拿着被插入的数据] 在[前面的有序数据]中[从后向前]扫描.
        [拿着被插入的数据]
        [前面的有序数据]
        [从后向前]

    10 30 20 15 60
    __ __ __ __ __
    0  1  2  3  4    - 数组A下标
-------------------------
拿出来一个数据10:

    10  - 天然有序 - 将其放到下标为 0 的位置
    __ __ __ __ __   - 数组B下标
    0  1  2  3  4
--------------------------
拿出来一个数据30:
    10 30   <- 30和10比较 - 大的放在后面
    __ __ __ __ __   - 数组B下标
    0  1  2  3  4
--------------------------
拿出来一个数据20:
    10 20 30
    __ __ __ __ __   - 数组B下标
    0  1  2  3  4

    将20和30比较 - 20<30 - 放在30左侧; 不能确定10和20关系, 比较20和10的关系, 20>10 - 20放右侧   //在右侧就不需要再比较了
--------------------------
拿出来一个数据15:
    10 15 20 30
    __ __ __ __ __   - 数组B下标
    0  1  2  3  4

    将15和30比较 - 15<30 - 放在30左侧
    将15和20比较 - 15<20 - 放在20左侧
    将15和10比较 - 15>10 - 放在10右侧   //在右侧就不需要再比较了
--------------------------
拿出来一个数据60:
    10 15 20 30 60
    __ __ __ __ __   - 数组B下标
    0  1  2  3  4
    
    将60和30比较 - 60>30 - 放在30右侧 - 不需要再次比较  //在右侧就不需要再比较了


优化 :
    40 30 20 15 60
    __ __ __ __ __
    0  1  2  3  4    - 数组A下标

int data[] = {40, 30, 20, 15, 60};

第一个数据天然有序
    20 30 40 15 60
    __ __ __ __ __
    0  1  2  3  4    - 数组A下标

----------------------
    40
    __ __ __ __ __
    0  1  2  3  4    - 数组A下标

----------------------
    int inserted = data[1];//30
    if(inserted < data[0]){
        data[1] = data[0];//data[1]=40
    }
    data[0] = inserted;//30
----------------------
    int inserted = data[2];//20
    if(inserted < data[1]){
        data[2] = data[1];//40
    }
    data[1] = inserted;

    int inserted = data[1];//20
    if(inserted < data[0]){
        data[1] = data[0];//data[1]=30
    }
    data[0] = inserted;//20

3.选择排序
    对于n个数据的无序数列遍历n-1次, 每次选中剩余数据的最小值, 放在对应的位置上

举例 :
    int a[5] = {9, 7, 5, 3, 1};

    9  7  5  3  1
    __ __ __ __ __
    0  1  2  3  4

第一次遍历 : 从下标为0的位置开始向后, 找出数据最小的值的下标, 然后和下标为0的数据交换位置.
    1  7  5  3  9
    __ __ __ __ __
    0  1  2  3  4
    最小的值1, 下标为4
    int tmp = data[0];
    data[0] = data[4];
    data[4] = tmp;

第二次遍历 : 从下标为1的位置开始向后, 找出无序数列 数据第二小的数据下标, 然后和下标为1的数据交换位置
    1  3  5  7  9
    __ __ __ __ __
    0  1  2  3  4

第三次遍历 : 找出第三小的值 - 和下标为2的位置做替换
    1  3  5  7  9
    __ __ __ __ __
    0  1  2  3  4

第四次遍历 : 找出第四小的值 - 和下标为3的位置做替换
    1  3  5  7  9
    __ __ __ __ __
    0  1  2  3  4

















mkdir sort
sort.h
sort.c
main.c

编译 :
    gcc main.c sort.c -o sort
运行 :
    ./sort
任务 :
    Makefile优化




----------------------
二.2个查找算法
