
总结:
第一个C语言程序
gcc编译器
变量 - 内存 - 使用内存
数据类型 - int / char / double / ... - 以一种不同的姿态 - 使用内存
进制转换 - 二进制 - 位 - 如何在内存存储 - 十进制/八进制/十六进制
运算符 - 内存中的数据如何计算
        ->  + - * / % = == != > < && || ! & | ^ << >> & *  三目
三大结构
    顺序结构
    分支结构
        if
        switch...case
    循环结构
        printf
数组 - 拿一堆数据 - 类型一样
    普遍性
    特殊性
        初始化
        一维数组
        二维数组
        地址
        动态数组
函数 - 语句放一块 - 打个包 - 形成一个功能
    function - 函数 - 功能
    特点
        参数
        返回值
指针 - 重要 - 内存 - 地址 - 指针
    只要 - 内存 - 有地址 - 拿到
    数组
    变量
    函数
    结构体
    二维数组
    字符串
    数组指针
字符串 - 显示 - 输入
    qq : 1234567
    qq : "1234567"

预处理指令 -
    提高便利性

大型程序开发 -
    根据功能模块划分
        显示
        任务属性
        服务器
        页面
        前端

结构体 -
    多个字节  - 类型不同
    内存

动态内存分配 - malloc + free

文件操作 - 掉电不丢失
--------------------------------------------------
今日内容:
数据结构和算法

问 : 什么是数据结构呢?
    研究计算机中数据之间的关系 和 存储方式
    数据的存储
    int age = 18;
    char* name = "hello";
    int arr[] = {13,14,15};

    数据的存储

    char* name[] = {"maji", "madong", "huoyaowen", "guodegang", "yueyunpeng"};
    可以存储数据 - 名字 - 没问题
    缺点 - 无法描述 - 数据之间的关系
    除了记录数据之外, 还需要 记录数据之间的关系

    变量 数组 结构体 动态内存分配 - 记录/存储 数据
    数据之间的关系 - no
    可以做到 - 数据结构 - 树结构

    数据结构:
    1.如何存储数据
    2.如何存储数据之间的关系
        |
        V
    为了后续数据的使用

问 : 为什么要使用数据结构

1.数据结构分类
    逻辑结构 : 数据之间的关系
    物理结构 : 数据的存储方式

2.逻辑结构
    集合结构 : 只强调总体, 不强调数据之间的关系  - 做公交车
    线性结构 : 描述数据之间的一对一的关系 排队打饭
        7 6 5 4 3 2 1 |出餐口
    树形结构 : 描述数据之间一对多的关系 家谱 / 高山流水
        爸爸 - 儿子1
            - 儿子2
            - 儿子3
    图形结构 : 描述数据之间的多对多的关系 网球拍 / 电话号

3.物理结构
    顺序结构 : 基于数组实现, 内存之间是连续的, 一个元素挨着一个元素
            _ _ _ _ _ _ _ _ _ _ _
    链式结构 : 每个元素之间的内存不一定/大概率不连续
            _      _ _ _       _      _ _
4. 数据结构研究的对象
    栈 队列 单链表 双链表 二叉树


算法 : 解决问题的方法
    准确性 - 必须可以彻底解决问题
    健壮性 - 在任何状态下不可以崩溃
前提

好算法 - 效率要高
    和计算机无关

    64位
    32位
        error

时间复杂度
    时间需要的越少 - 效率越高 - 估值
    int  a = 0;
    for(int i = 0; i < n; i++)// i; 0->n -> n+1
        a++;    -> 执行n次
    代码 : n+1 + n = 2n + 1

    for(int i = 0 ; i < n; i++){    //n+1
        for(int j < 0;j < m; j++)   //(m+1)*n
            a++;    //m*n
    }
    代码 : n+1 + n*(m+1) + n*m
计算时间复杂度 :
    将变量变大无限大
    2n + 1 -> 无限大 -> n - O(n)
    n + n * n + n * n = 2n² + n - O(n²)

    大O计法 :
        O(频度)

    解决同一个问题, 时间复杂度越小越好


空间复杂度
    运行占用内存空间，包括：
        1、程序代码所占用空间
        2、输入输出空间
        3、临时申请的空间

    int a[5];
    scanf("%d", &n);
    int a[n];


权衡2者 - 主要看时间复杂度  //因为空间复杂度很难把控

1. 获取数据, 按照一定的关系存储起来 - 数据结构
2. 处理数据, 如何处理数据 - 算法

------------------------------------------
栈
先进后出 后进先出
内存是连续的 - 数组的方式存储数据 - 具有随机访问的能力
入栈 - 将数据保存到栈的过程 - 压栈 - push stack
出栈 - 从栈中获取数据的过程 - 弹栈 - pop stack

typedef struct stack{
    int* arr;//作为栈的首地址
    int cap;//作为栈的容量
    int top;//栈顶
};
分析:
1.随机访问能力
    数组名[下标] - 表示数组中某个下标的数据
    有一块存储区
2.arr - 首地址
    动态内存分配 - arr指向他
3.栈的容量 - cap
4.将数据入栈到哪个位置上, 从栈的哪个位置来获取数据
    需要有一个标识 - 标识数据可以放到哪里 - 可以从哪里获取
    top 栈顶
        记录读写的位置 - 下标 - 记录读写的位置

    问题 : 如果栈中没有任何数据, 此时栈顶top应为多少? - 0
5.栈顶 - 出栈入栈位置下标
    入栈和出栈的位置下标

定义好栈 - 用户/客户 - 看到封装好的函数和参数 - 调用 + 传参

6.初始化函数
    arr - 首地址 - 需要内存 - malloc分配
    cap - 容量
    top - 栈顶位置

    int* arr - 我们想要向栈中放入int类型数据

7.判断满和空的标志 - 判断 top - cap的值
    if  top == cap -> full

    空 - top == 0

8. 入栈函数
    将数据放到下标为top的存储区中
    arr[top] = data; -> 数据的入栈
    top++;

9.出栈函数
    将下标为top的存储区数据获取
    top--;
    return arr[top];

10. 获取栈的数据个数
    数据个数 == top

11. 编译步骤
    gcc main.c stack.c -o stack


模拟实际编程 :
    main.c - 测试
    stack.h - 声明
    stack.c - 定义

vim -p 多个文件 同时打开
gt - 不同文件之间切换


手机 主板 / 电池 / 红外 / 摄像头 / ...- 屏幕 <--- 面对 <----

