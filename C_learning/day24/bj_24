
今日内容:
一.队列 - 核心 - queue
特点 - 先进先出 - FIFO - first in  first out
    - FIFO缓冲区

类似于水管
举例 :
    蓝牙 - UART协议
    CPU核-------uart协议-----|数据3,数据2,数据1|----------->蓝牙设备
                                内存
            先把数据1从缓冲区(FIFO) - 蓝牙 - 数据2 - 蓝牙 - 数据3 - 蓝牙

大名鼎鼎的三大队列 :

描述队列的数据结构
typedef struct queue{
    int* arr;//队列的首地址
    int cap;//容量
    int size;//有效数据个数
    int front;//队首 - 出队
    int rear;//队尾 - 入队
}queue_t;

分析:
1.需要有成员
    描述 向队列保存数据的下标
    描述 从队列获取数据的下标
2.入队和出队
    入队 - 将数据保存到队列内存的过程 - 操作队尾 - rear
    出队 - 从队列内存中去除数据的过程 - 操作队首 - front

    [队尾 和 队首 - 表示的是要入队和出队的位置]
     rear   front
3.入队
    操作的是rear, 和front没有关系
    入队 - 修改 - rear - 入队的位置需要改变
               - front - 出队的位置 - 不需要改
4.出队
    操作的是front, 和rear没有关系
    出队 - 修改 - front - 出队的位置需要改变
               - rear - 入队的位置不需要改变
5.循环入队
    如果满 - 无法入队

    cap - 容量

    rear == cap -> 认为将数据放到了下标最大的位置上
    此时rear==cap, 如果有空的位置, 必定是在下标为0的位置上有空的位置
    循环入队:
    if(rear >= cap)
        rear = 0;//重置 - 如果还要入队, 将新的数据入队到下标为0的位置
    rear = 0, 将来入队 - 将数据放到下标为rear的位置上 - 放完后 - rear++

6.循环出队
    如果将所有的数据全部出队 - 队列就空了
    再一次入队
    首先 : 先去判断队列为非空
    front == cap, 意味着已经从队列中获取了cap个数据了, 拿到头了
    if(front >= cap)
        front = 0;//重置front - 从下标为0的位置出队

7.判断满 和 空
    queue->size - 当前队列中有效数据个数
满 :
    size == cap -> 满
    size = 有效数据个数
    cap = 容量

空 :
    当前队列中有效数据个数为 0
    size == 0
        成立 - 空
        不成立 - 非空


如果一个盒子, 盒子里面有5个格子, 5个格子里面放了五颗糖, 盒子满了吗 - 不确定
    只是说 - 放了五颗糖
于此同时, 从盒子中拿了2颗糖 - 剩下三颗糖

问题 :
    如果此时, 向队列中, 放入3个数据, 获取1个数据
        front = 1
        rear = 3 - 当我们向其中放入三个数据之后的话, 此时rear=3,
            此时如果队列非满, 继续入队, 下标为几的位置入队

8.
    入队 - 判断是否为满 - queue_full判断 - 非满 - 入队
        - 有效数据多了一个 - size++

9. 程序编译
    gcc main.c queue.c -o queue

10. 程序运行
    ./queue


代码 :
queue.h //声明
queue.c //定义
main.c  //测试


录播视频 :
    stdc - 标C - day20
    数据结构 - day01 - 周日开始的视频
