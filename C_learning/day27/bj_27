
今日内容:
一.双链表

分析:
1.根据编号获取数据

count = 0;
    如果此时不循环 : count = 0, pmid -> 第0个数据
    如果此时循环1次 : count = 1, pmid -> 第1个数据
    如果此时循环2次 : count = 2, pmid -> 第2个数据
    如果此时循环n次 : count = n, pmid -> 第n个数据

如果index = 5, 获取下标为5的节点数据
    只需要让index = count = 5
    只要循环5次, count等于5, 此时pmid指向的就是第5个数据

2.清除链表
新插入的节点 - malloc分配 - 必须释放的
头结点和尾节点 - 不需要释放 - 栈区内存 - 局部变量/全局变量

前提 - 链表非空 - 头节点的下一个节点不是尾节点

编译过程 :
    gcc main.c list.c -o list

运行过程:
    ./list

修改链表中的数据 - list_get()

void list_mod(list_t* list, int index, int data){

}



--------------
二.递归函数
main函数 - 调用 - foo函数
函数A 调用 函数B

递归函数 - 函数自身调用自身
函数A 调用 函数A

好像是对于自身的无限循环的调用

void foo(void){
    printf(">>>");
    foo();
}

foo() -> foo() -> foo() -> ...

int i = 0;
fo(;;){
    printf("...");
    i++;
    if(i > 10)
        break;
}

recu.c

利用递归函数实现打印: 1 2 3
明确:
    函数调用和返回
    A <-> B <-> C <-> D  //A调用B，B调用C，C调用D，然D返回给C，C返回给B，B返回给A
    递归函数同样遵循
    A <-> A <-> A <-> A
分析:
    递归函数就是将重复的事情执行再执行, 面对一个题目,
    这个题目中是否有重复的事情
    目前题目中重复的事情就是打印一个数字
    打印1 打印2 打印3 都是一样, 只是打印的数字不同而已
    使用递归函数
1.先把重复的单元写上
2.递归调用
3.设置退出条件

应用 :

写递归函数前提 :
    认为/假设 - 这个函数已经可以完美使用了

假设print(max)可以输出1 2 3 4 .. max的值
print(max) : 1 2 3 4 ... (max-1) max
此时print(max-1)必须可以输出1 2 3 4 ... (max-1)的值
print(max-1) : 1 2 3 4 5 ... (max-1)
    推导得到:
print(max);
        输出 : 1 2 3 4 5 ... (max-1) max
等价于
print(max-1) + printf("max ");
        输出 : 1 2 3 4 5 ... (max-1)
        +
        max
        printf(max)

print函数参数是max-1和max的结果 区别在哪里呢?
    print参数是max比参数是max-1, 多输出了一个max
    参数max-1只需要多输出一个max - 等价于参数是max-1的函数


recu2.c

int max = 3;
print(3)
    print(2)

练习:
斐波那契数列
    1 1 2 3 5 8 13 21 34 55 89 144 233 ...

第1个数, 第2个数 - 1

第n个数是多少
    f(n) = f(n-1) + f(n-2);

第n个数等于前两个数和


求n的阶乘  :
n!     = n * (n-1) * (n-2) * ... * 1
(n-1)! =     (n-1) * (n-2) * ... * 1

n! = n * (n-1)!
fact(n) = n * fact(n-1)

1的阶乘 == 1

fact.c

三.有序二叉树  - 递归函数

1.树的概念
树  - 一对多的数据结构

线性的关系
__ __ __

一个节点可以指向多个节点 - 一对多

数存储结构 - 一对多的数据结构
树的存储结构中每个数据元素称为 一个节点

树根节点 - 根节点 - 每一棵树有且仅有一个根节点 - 单根性

父节点 - 每个子节点只有一个父节点
子结点
兄弟节点 -

节点的层次
    根节点所在的层次 - 第一层
    根节点所在子结点 - 第二层
    根节点的子结点的子节点 - 第三层
    ...

节点的度
    一个节点拥有的子节点数量, 称为该节点的度

如果一个节点有3个子节点, 该节点的度为3.

2.二叉树
    每个节点最多有两个子节点的树
    有序
    无序 - 不研究
二叉树组成 :
    根节点
    左子树 - 将左子节点看做为新的根节点, 生发的树
    右子树 - 将右子节点看做为新的根节点, 生发的树

    递归解决问题

3.有序二叉树
    一般来讲, 如果左子树不为空的话, 左子树的元素值小于根节点,
             如果右子树不为空的话, 右子树的元素值大于根节点
    一句话 - 不管站在哪个节点上,, 左边的值小于中间的值, 小于右边的值

    左 根 右
