

练习:
1.求1-100之间的所有奇数
    1 3 5 7 9 11 ...
    1.不能被2整除

    for(int i = 1; i <= 100; i++){
        if(i%2)//不是0就是1
            printf("%d ", i);
    }
    printf("\n");

    i%2
        ==0 - 结果为假 - 不打印数字
        ==1 - 结果为真 - 打印数字


2.输入一个整数, 计算该整数的位数
    55 - 2
    556 - 3
    98989 - 5
/*计算位数*/
#include <stdio.h>
int main(void) {
    printf("请输入一个整数:");
    int integer;
    scanf("%d", &integer);

    int len = 0; //记录位数

    for(;;) {
        len++;
        integer = integer / 10;
        if(integer == 0)
            break;
    }
    printf("有效位数是:%d\n", len);
    return 0;
}
3.打印10行20列的*
*******************
*******************
*******************
*******************
*******************
*******************
*******************
*******************
*******************
*******************
#include <stdio.h>
int main(void) {
    int h = 10;
    int i, j;
    for(i = 0; i < 10; i++) { //负责打印10行
        for(j = 0; j < 20; j++)
            printf("*");
        printf("\n");
    }
    return 0;
}
4.判断一个整数的十位是否是8
/*
    练习题：
    输入一个整数，判断其十位是否为8.
*/

int main(void)
{
    int num;
    printf("请输入一个整数:\n");
    scanf("%d", &num);

    if( (num % 100) / 10 == 8 )
        printf("整数%d的十位数字是8.\n", num);
    else
        printf("整数%d的十位数字不是8.\n", num);

    return 0;
}

5.从键盘输入一个整数, 判断是否是8的倍数
/*
    练习题：
    输入一个整数，三种方式判断是否为8的倍数.
*/

int main(void)
{
    int num;
    printf("请输入一个整数:\n");
    scanf("%d", &num);

    // 方案一
    if( (num / 8) * 8 == num )
        printf("整数%d是8的倍数.\n", num);
    else
        printf("整数%d不是8的倍数.\n", num);

    // 方案二
    if( num % 8 == 0 )
        printf("整数%d是8的倍数.\n", num);
    else
        printf("整数%d不是8的倍数.\n", num);

    return 0;
}


今日内容:
一.循环
1.空语句
    就是一个 ; , 什么也没有 - 什么也不做
    02empty.c
    for(;;); //该死循环要执行的内容就是, 什么也不执行
2.goto语句
    有争议 - 大多数公司 - 不建议/不允许
    03goto.c

    goto - 强大到 - 想到哪就到哪
        破坏掉了整个三大结构
        谨慎

主要 : for - while
    如果循环的次数可以确定, 使用for循环
    将printf语句打印10次
    for(int i = 0; i < 10; i++)
        printf("...");

    如果循环的次数不确定, 使用while循环
        条件循环 - 满足条件才循环 - 否则不循环
二.数组
组 - 多 - 扎堆 - 班级分组
    数组 - 数据放一墩儿
数组 - 分配内存的第二种方式
变量 - 分配内存的第一种方式

定义变量 - 分配内存 - 缺点 : 无法大量分配内存
    40个字节 -
    int var1, var2, var3, var4,... - 可以做到 - 缺点 - 麻烦
一次性大量分配 - 数组

- 数组是用来存储多个相同类型数据的内存分配方法
    数据类型一样
    内存是连续 - 一个挨着一个
- 语法格式 :
    元素数据类型 数组名[元素个数] = {初始值};
- 举例:
    int a[5] = {1,2,3,4,5};
  分析 :
  1.定义了数组 - 名为a
  2.5 - 分配了5个元素
  3. int - 分配的5个元素, 每个元素都是int类型
  4. {1,2,3,4,5} - 给这5个元素初始化为1 2 3 4 5
  5. 5 * 4 = 20
  - 一次性开辟了20个字节的内存空间 - 简单
- 数组元素就是数组中存储的数据, 一般有多个
- 概念 :
    数组下标 - 索引 - 就是数组元素在数组中的位置, 从0开始, 依次递增
    变化返回 - 0 ~ size-1
    
    访问数组元素 :
    格式 :
        数组名[下标]
    访问数组元素下标为0的数据 : a[0]

    04array.c
    
- 地址
    数组名是数组首元素的地址, 也是数组的首地址

    printf("%d\n", *&a[0]);
    ==
    printf("%d\n", a[0]);

    *&a[0] = 100;
- 长度
    数组元素的个数 - 数组长度

int score[50];  //定义数组, score,存储50个int变量, 表示的是学生的成绩
    19号 - 23号出成绩 - 将成绩 - 存储到score数组中
是否要初始化呢?
    - 初始化 - 初始化什么呢? - 无法将成绩直接初始化到数组中
    - 不初始化 - 可以

- 数组的初始化

int arr[10] = {1,2,3,4,5,6,7,8,9,10};

分配了10个int类型存储空间 - 初始化为1-10
__ __ __ __ __ __ __ __ __ __
0  1  2  3  4  5  6  7  8  9    数组下标
1  2  3  4  5  6  7  8  9  10   数组数据

-------------

int arr[10] = {1};
分配了10个int类型存储空间 - 初始化了一个1
从下标为0的位置开始放数据
显示初始化 - 初始化
未显示初始化 - 0
__ __ __ __ __ __ __ __ __ __
0  1  2  3  4  5  6  7  8  9    数组下标
1  0  0  0  0  0  0  0  0  0    数组数据

-----------
int arr[10] = {1,2};
分配了10个int类型存储空间 - 初始化了一个1,2
__ __ __ __ __ __ __ __ __ __
0  1  2  3  4  5  6  7  8  9    数组下标
1  2  0  0  0  0  0  0  0  0    数组数据

-----------
int arr[10] = {0};//全0
__ __ __ __ __ __ __ __ __ __
0  1  2  3  4  5  6  7  8  9    数组下标
0  0  0  0  0  0  0  0  0  0    数组数据

-----------
int arr[10] = {};//全0
__ __ __ __ __ __ __ __ __ __
0  1  2  3  4  5  6  7  8  9    数组下标
0  0  0  0  0  0  0  0  0  0    数组数据

定义数组 - 不初始化元素个数

int arr[] = {1,2,3,4,5};
    根据初始化元素个数 - 分配5个int类型的内存空间 - 默认元素个数为5

int arr[]; //error
    编译器 - 蒙圈 - 报错

int arr[5]; //一点也初始化, 不建议 - 随机的值
    分配5个int的内存空间 - 值 - 随机

int arr[5] = {0};

arr[4] = 100;

全初始化
部分初始化
不初始化
初始化为全0

- 优化数组的使用 - sizeof  - 五星级重要 - 背住 - 数学公式
    数组名是数组的首地址等于第一个元素的首地址
    sizeof -
        sizeof(数组名) - 数组占用的内存大小
    数组中每个元素类型 - 相同
    sizeof(数组名[0]) - 数组元素占据字节大小
    sizeof(数组名) / sizeof(数组名[0]) = 元素个数

- 动态数组 - 变长数组
    - C99 支持动态数组
    - 定义数组可以通过变量来指定数组的长度

    int n;
    scanf("%d", &n);
    int a[n];//C99动态数组
        - n是多少 - 数组元素个数就是多少
    06dynamic_arr.c

    n输入后 - 确定了 - 变长数组吗
    问题:
    编译: 预处理 - 编译 - 汇编 - 链接
        n的值确定了吗?
    运行阶段: ./06dynamic_arr
        scanf();
        n的值确定了吗

    换个问题 : scanf之前n的值确定吗? - 运行的时候

练习:
1.输入10个整数, 逆序输出.


数组名作为函数参数：
    1、数组名就是数组的首地址。因此在数组名作函数参数时所进行的传送只是地址的传送，也就是说把实参数组的首地址赋予
     形参数组名。形参数组名取得该首地址之后，也就等于有了实在的数组。实际上是形参数组和实参数组为同一数组，共同拥有一段内存空间。
    2、数组名作为函数参数，本质上是数组名，地址的传递
        #include<stdio.h>
        int sort(int a[5])
        {
            printf("%d",a[0]);
        }
        int sort1(int a[])
        {
            printf("%d",a[0]);
        }
        int sort2(int a[],int n)
        {
            printf("%d",a[0]);
        }
        int main()
        {
            int b[1]={1,2};
            sort(b);
            sort1(b);
            sort2(n,1);
            return 0;
        }
    3、多维数组作为函数参数，可以省略第一维数组
         int MA(int a[3][10])
        或
            int MA(int a[][10])。

    4、用数组名作为函数参数时还应注意以下几点：
        ①形参数组和实参数组的类型必须一致，否则将引起错误。
        ②形参数组和实参数组的长度可以不相同，因为在调用时，只传送首地址而不检查形参数组的长度。当形参数组的长度与实参数组不一致时，
         虽不至于出现语法错误(编译能通过)，但程序执行结果将与实际不符，这是应予以注意的。
        ③在函数形参表中，允许不给出形参数组的长度，或用一个变量来表示数组元素的个数。例如，可以写为：
                void nzp(int a[])
            或写为
                void nzp( int a[], int n )
