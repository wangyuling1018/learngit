今日内容:
单链表和双链表

栈和队列 -
    基于数组实现 -- 顺序结构
    malloc - 动态内存分配

栈和队列基于数组 - malloc
    malloc(sizeof(int) * 100)
        - 分配了100个int类型存储区 - 再想更改 - 相对麻烦

链式结构 -
    使用链式结构存储的数据元素, 其[内存存储位置]是[随机]的
    链式结构 - 存储数据问题 - 如何让存储的顺序具备先后顺序 - 指针

-------------------
单链表
1.案例
    定义三个学生信息, 通过第一个学生找到第二个学生的信息, 通过第二个学生找到第三个学生的信息.
        可以通过第一个学生最终可以找到第三个学生.
    
struct student{
    char name[32];//姓名
    int age;//年龄
};

student.c
分析:
1.第一版代码
//声明描述学生信息的结构体
typedef struct student{
    char name[32];
    int age;
}stu_t;

int main(void){
    //定义初始化三个学生的信息
    stu_t s1 = {.name = "孙悟空", .age = 600};
    stu_t s2 = {.name = "猪八戒", .age = 800};
    stu_t s3 = {.name = "沙悟净", .age = 750};

2.地址 - 通过地址可以找到某个变量[数组, 结构体]
如果存储了结构体变量的地址, 就可以找到某个结构体变量
如果s1存储了s2的地址, 就可以通过s1找到s2
如果s2存储了s3的地址, 就可以通过s2找到s3

3.第二版代码
//声明描述学生信息的结构体
typedef struct student{
    char name[32];
    int age;
    struct student* next;//保存下一个学生信息节点/变量的首地址
}stu_t;


    //定义初始化三个学生的信息
    stu_t s1 = {.name = "孙悟空", .age = 600, .next = NULL};
    stu_t s2 = {.name = "猪八戒", .age = 800, .next = NULL};
    stu_t s3 = {.name = "沙悟净", .age = 750, .next = NULL};

    s1.next = &s2;//s1可以通过next指针找到s2
    s2.next = &s3;//s2可以通过next指针找到s3

s3的next指针,什么都不要

4.优化
    书 - 封皮

    开始的节点  - 头节点
        不存储有效信息
    结束的节点  - 尾节点
        不存储有效信息

    头节点和尾节点 - 不是必须的 - 只是为了方便解决问题

5.优化2
    pnode - 循环的范围 -
        从头节点开始, 到最后一个有效节点结束

    pmid - 循环的范围
        从第一个有效节点开始, 到tail节点结束
    
        pmid指向的节点永远是pnode的下一个节点

    如果pmid != &tail
        此时pmid的循环范围 - 从第一个有效节点开始, 到最后一个有效节点结束

-----------------------
数据结构 :
    存储区 - 分配
    对于存储区的操作函数 - 操作函数

单链表 :

头节点 - 链表的开始
    头节点永远指向链表的第一个有效节点
尾节点 - 链表的结束

对于链表而言 - 每一个元素 - 一个节点
    每一个节点都可以分配两部分:
        |数据元素本身|指向后继元素的指针|

单链表 :
    //描述节点信息的结构体
    struct node{
        int data;//节点数据
        struct node* next;//保存下一个节点的首地址
    };
    //描述整个单链表属性的结构体
    struct list{
        struct node* head;//头节点指针
        struct node* tail;//尾节点指针
    };
    如果想要初始化一个单链表 - 没有任何有效数据 - 只有一个头节点+尾节点
        后续想要添加其他节点 - 动态分配内存将其添加到头节点和尾节点之间

测试代码:
    mkdir list
    list.h
    list.c
    main.c

    list_t list ;

分析:
1.游标法
    pfirst -
        头节点 - 最后一个有效节点
    pmid
        第一个有效节点 - 尾节点
    plast


13,14 - 肯定过来
    双链表
    二叉树

进程间通信 :
    消息队列

嵌入式:
    工作队列
    等待队列
