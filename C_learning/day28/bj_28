
有序二叉树  - 递归函数

1.树的概念
树  - 一对多的数据结构

线性的关系
__ __ __

一个节点可以指向多个节点 - 一对多

树存储结构 - 一对多的数据结构
树存储结构中每个数据元素称为 节点

树根节点 - 根节点 - 每一棵树有且仅有一个根节点 - 单根性

父节点 - 每个子节点只有一个父节点
子结点
兄弟节点 -

节点的层次
    根节点所在的层次 - 第一层
    根节点所在子结点 - 第二层
    根节点的子结点的子节点 - 第三层
    ...

节点的度
    一个节点拥有的子节点数量, 称为该节点的度

如果一个节点有3个子节点, 该节点的度为3.

2.二叉树
    每个节点最多有两个子节点的树
    有序
    无序 - 不研究
二叉树组成 :
    根节点
    左子树 - 将左子节点看做为新的根节点, 生发的树
    右子树 - 将右子节点看做为新的根节点, 生发的树

    递归解决问题

3.有序二叉树
    一般来讲, 如果左子树不为空的话, 左子树的元素值小于根节点,
             如果右子树不为空的话, 右子树的元素值大于根节点
    一句话 - 不管站在哪个节点上,, 左边的值小于中间的值, 小于右边的值

    左 根 右
4.遍历二叉树 - 有序二叉树
    先序遍历 处理节点本身的数据 -> 处理左子节点 -> 处理右子节点 (自->左->右)
    中序遍历 处理左子节点 -> 处理节点本身的数据 -> 处理右子节点 (左->自->右)
    后序遍历 处理左子节点 -> 处理右子节点 -> 处理节点本身的数据 (左->右->自)


    第一步要找的一定是根节点

5.使用代码实现[有序二叉树]
声明描述节点属性的结构体
    struct node{
        int data;//数据
        //两个指针 : 存储左子节点地址, 存储右子节点地址
        struct node* left;//保存左子节点地址
        struct node* right;//保存右子节点地址
    };
声明描述整棵树属性的结构体
    struct tree{
        struct node* root;//保存根节点的首地址
        int cnt;
    };

在一棵树中只要有了根节点, 可以找到所有的节点.

6.编辑程序
mkdir tree
tree.h
tree.c
main.c

7.分析
7.1.遍历二叉树的时候
    travel(proot); //认为该函数可以正常使用
        printf("%d", proot->data);//节点自身
        travel(proot->left);//将左子节点看做为新的根节点
        travel(proot->right);//将右子节点看做为新的根节点
7.2.插入数据
    比较 - 递归 - 从根节点开始进行比较

7.3.删除节点
    找节点 - 找到要删除的节点
    找新爹 - 有左子节点 - 将右子节点当做左子节点的父节点
    提一级 - 原先的右子节点要取代原先的父节点的位置

7.4.修改节点值
    修改 - 无法修改
    完成修改的效果
    先将20所在节点删除
    将130所在节点插入到二叉树中

8.编译
    gcc  -DA/B/C main.c tree.c -o tree


常用的算法 :
1.4个排序算法

2.2个查找算法
