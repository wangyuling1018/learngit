
今日内容:
链表 - 各个数据元素之间的内存不一定连续
    使用指针将其连接起来
    head -> l1 -> l2 -> l3 -> l4 > ... -> tail
单链表的特点:
    每个节点都包含一个指针, 指向了下一个节点的地址
单链表的缺点 :
    场景, 需要通过一个节点来找到上一个节点 - 单链表无法做到
使用双链表

问题 : 一个节点如何找到上一个节点的呢?
答 : 通过指针
解决方案 :
    1.保持原有的特点 - 可以通过一个节点找到下一个节点
    2.添加新的特点 - 可以通过一个节点找到上一个节点
一.双链表
//描述节点的结构体
struct node{
    int data;
    struct node* next;//指向下一个节点的首地址
    struct node* prev;//指向上一个节点的首地址
};
//描述双链表的结构体
struct list{
    struct node head;
    struct node tail;
};

mkdir list
list.h
list.c
main.c

分析:
1.初始化函数
    目前没有有效数据
        只有一个头节点和一个尾节点
    头节点和尾节点 -有效数据都是0

2.判断空
    空 - 只有头节点和尾节点
    如果头节点的下一个节点是尾节点 - 为空

3.如何插入节点
    让pfirst指向要插入的前一个节点, 让pmid指向要插入的后一个节点
    将新的节点插入到pfirst和pmid之间即可

4.删除有效节点
    让pmid指向要删除的节点


-------------------
二.递归函数
三.二叉树
