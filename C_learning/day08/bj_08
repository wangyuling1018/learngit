练习结果 :
1. int a = 10, b = 9, c;
c = (--a == b++) ? --a : b++;
    a = 8
    b = 10
    c = 8
2. int a = 10;
    printf("%d\n", a++ + ++a + ++a);//35
    printf("a = %d\n", a);//13
    //提醒 - 别这么玩儿

01exec.c

D = 条件表达式A ? 表达式1 : 表达式2;
    如果A为真, 表达式1作为结果 - 表达式2不再计算
    如果A为假, 表达式2作为结果 - 表达式1不再计算

今日内容 :
一.运算符
1.位运算 -> 转为二进制
- 专门对内存中的[二进制数据]进行各种以bit为基本单位的运算
    变量 - 转换为二进制 - 计算
C 语言提供的位运算符有 :
    &   - 按位与
    |   - 按位或
    ^   - 按位异或
    ~   - 按位取反
- 按位与  &
    语法格式 : C = A & B;
    > 参与运算的两位都是1结果为1, 否则为0
        A[n]    -数据A的bit[n]位 - 1 或者 0
        A[n]    B[n]    与运算
        1       1         1
        0       1         0
                -> 任何数据和1做按位与, 结果不变
        1       0         0
        0       0         0
                -> 任何数据和0做按位与, 结果为0

    举例 :  0XB1 0XEF 做按位与运算
     7 654 3210
    [1]011 0001   0XB1
    [1]110 1111   0XEF
    -----------&
     1 010 0001     -> 0XA1

     0xb1 & 0xef

- 按位或 |
    语法格式 : C = A | B;
    >参与运算的两位都是0结果为0, 否则为1
        A[n]    B[n]    或运算
        1       1       1
        0       1       1
            -> 任何数据和1做按位或, 结果为1
        1       0       1
        0       0       0
            -> 任何数据和0做按位或, 结果保持不变


    举例:   0XB1 0XE7 做按位或运算
     7 654 3210
    [1]011 0001   0XB1
    [1]110 0111   0XE7
    -----------|
     1 111 0111   0XFF

- 按位异或 ^
    语法格式 : C = A ^ B;
    >相同为0, 不同为1
        A[n]    B[n]    异或运算
        0       1       1
        1       1       0
            ->任何数据和1做异或, 得到翻转值 - 0>1 1>0
        0       0       0
        1       0       1
            ->任何数据和0做异或, 结果保持不变

    1010 1010 A
    0010 0100 B
    ---------^
    1000 1110

- 按位取反 ~
    语法格式 : C = ~A;
    > 1变0, 0变1
        0110 0001   0x61
        ----------~
        1001 1110   0x9e

    0x5a -> 0101 1010
            -----------~
            1010 0101 0xa5

02bit.c

☆ 五星级核心
    将GPIOCOUT转换为二进制 - X为变量转换为二进制后的每个数位 - 1 / 0
        数据的数位上的值 - 不确定
    嵌入式 - 寄存器 - 4个字节 - 位运算
        控制硬件 -
        GPIOCOUT - 当做变量名 - 4字节变量
        将改变量的[5]设置为0, 让其他bit位保持不变  -> 控制硬件
    31          ...          98 76543210
    X XXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX GPIOCOUT
    1 1111111 11111111 11111111 11011111    0XFFFFFFDF
    -------------------------------------&
    X XXXXXXX XXXXXXXX XXXXXXXX XX0XXXXX bit[5]=0的GPIOCOUT

    GPIOCOUT = GPIOCOUT & 0XFFFFFFDF;
        GPIOCOUT &= 0XFFFFFFDF;

        将改变量的[5]设置为1, 让其他bit位保持不变  -> 控制硬件
    31          ...          98 76543210
    X XXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX GPIOCOUT
    0 0000000 00000000 00000000 00100000    0X00 00 00 20
    -------------------------------------|
    X XXXXXXX XXXXXXXX XXXXXXXX XX1XXXXX bit[5]=1的GPIOCOUT
    GPIOCOUT = GPIOCOUT | 0X20;
        GPIOCOUT |= 0X20; //缺点 - 可读性不强
        
    功能 - 缺点 - 可读性不强 - 怎么办?移位运算

场景 :
    加密算法 解密算法
    硬件驱动

- 移位运算  - 以位为单位 - 运算
    C语言中提供了两种移位运算符
    << 左移运算符
    >> 右移运算符

    int val;
        val<<n -> val左移n位
        val>>n -> val右移n位

- 左移 <<
    移位有可能发生正负转换

    每个bit依次左移, 低位补0, 高位丢弃
    - 有符号 - char
                        76543210
    1010 1010 << 1 = [1]01010100
    -86               |  84
                      V
                      丢弃

    符号位原本是1 - 左移1位 - 最高位变为0 -
        负数                   正数


    左移1位 - 最高位, 移出去 - 丢弃
           - 最低位, 空出来 - 补0
---------
    - 有符号 - char
                          76543210
    1010 1010 << 2 =  [10]10101000

    左移2位 - 最高2位, 移出去 - 丢弃
           - 最低2位, 空出来 - 补0

----------
    - 无符号 - unsigned char
                        76543210
    1010 1010 << 1 = [1]01010100
    179
    
    左移1位 - 最高位, 移出去 - 丢弃
           - 最低位, 空出来 - 补0

-----------
>> - 右移
    - 有符号数 - char
                     7 6543210
    10101010 >> 1 = <1>1010101[0]
    -86                 -43

    右移1位 - 最低1位,移出去 - 丢弃
           - 最高1位,空出来 - 填充符号位
                            - 负数 - 符号位 - 1 - 填充1
                            - 正数 - 符号位 - 0 - 填充0

                    76543210
    10101010 >> 2 = 11101010 10

    - 无符号数 - unsigned char
                     7 6543210
    10101010 >> 1 = <0>1010101[0]
    170                 85
    右移1位 - 最低1位,移出去 - 丢弃
           - 最高1位,空出来 - 补0
高位溢出
问题 :
    移位后的数据是否会发生变化 - 不会发生变化
    char a = 0x5a;
        a<<2 -> a的值是否发生变化 - 不变  //a是参与运算，a<<2表达式的值会发生变化
    
    int a = 5;
    int b = a * 5;

    int c = a & b;//a和b的也不变
    int d = a | c;//a和c的也不变

char a = 0x5a;

             76543210
          01 01101000   a<<2
char b = a<<2;//将高2位丢弃掉              //高位溢出
short c = a<<2;//不会将高2位丢弃掉, 0x168。 //高位没有溢出

    char a, b;
    a = 0xa5;//10100101 -> 0xa5
    b = a >> 2;//11101001 -> 0xe9
    printf("a = %#x, b = %#x\n", a, b);
a和b都是作为char类型,
    %#x -> a -> 0xa5 -> 负数 -> 0xffffffa5

如果后续的char类型数据 - 十六进制方式显示
    正数 - %#x %#hhx
    负数 - %#hhx


    a = 0xffffffa5, b = 0xffffffe9


十六进制 - 没有正负之分
    char a = 0xa5;//1010 0101 -> 0xa5
    0xa5 -> 正数负数

十六进制 - 只是一个表示方式
        - 使用十六进制表示一个数


-10 10
    二进制
    十六进制
    八进制

李四
    家里 - 小四
    学校 - 阿四
    单位 - 小李


01001010010101010 -> 二进制
-------------------~
10110101101010101
11111110000000000
-------------------&
10110100000000000  -> 发送的及时 网络 -> B -> 解密


-10
    十六进制 : 一个负数使用十六进制的方式表示出来
    二进制 : 一个负数使用二进制的方式表示出来
    八进制 : 一个负数使用八进制的方式表示出来

-10 -> 二进制 -> 每三位 -> 八进制


☆ 五星级核心
    将GPIOCOUT转换为二进制 - X为变量转换为二进制后的每个数位 - 1 / 0
        数据的数位上的值 - 不确定
    嵌入式 - 寄存器 - 4个字节 - 位运算
        控制硬件 -
        GPIOCOUT - 当做变量名 - 4字节变量
        将改变量的[5]设置为0, 让其他bit位保持不变  -> 控制硬件
    31          ...          98 76543210
    X XXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX GPIOCOUT
    1 1111111 11111111 11111111 11011111    0XFFFFFFDF
    -------------------------------------&
    X XXXXXXX XXXXXXXX XXXXXXXX XX0XXXXX bit[5]=0的GPIOCOUT

    GPIOCOUT = GPIOCOUT & 0XFFFFFFDF;
        GPIOCOUT &= 0XFFFFFFDF;


    31          ...          98 76543210
    1 1111111 11111111 11111111 11011111    0XFFFFFFDF
    -------------------------------------~
    0 0000000 00000000 00000000 00100000    0x20
        0XFFFFFFDF == ~(0X20)
        GPIOCOUT &= ~(0X20);

    31          ...           9876543210
    0 0000000 00000000 00000000000100000   1 << 5
                    0x20 == 1<<5
        GPIOCOUT &= ~(0X20);
        ==
        0XFFFFFFDF == ~(1<<5);

        GPIOCOUT &= 0XFFFFFFDF;
        ==
        GPIOCOUT &= ~(1<<5);//GPIOCOUT[5]=0

        GPIOCOUT &= ~(1<<n);//GPIOCOUT[n]=0

        将改变量的[5]设置为1, 让其他bit位保持不变  -> 控制硬件
    31          ...          98 76543210
    X XXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX GPIOCOUT
    0 0000000 00000000 00000000 00100000    0X00 00 00 20
    -------------------------------------|
    X XXXXXXX XXXXXXXX XXXXXXXX XX1XXXXX bit[5]=1的GPIOCOUT
    GPIOCOUT = GPIOCOUT | 0X20;
        GPIOCOUT |= 0X20;
        
    功能 - 缺点 - 可读性不强 - 怎么办?
    课下 -> GPIOCOUT[n]=1;
    
