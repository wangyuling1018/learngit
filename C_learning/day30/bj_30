
后天 - 8月20号 - 晚上七点半 - Linux下C编程 - 张超老师

今日内容:
一.快速排序 - 递归函数
举例 :
    0 10 80 30 60 50 40 70 20 90 100
思路 :
    找出一个基准值, 让他的数据小于该数据, 右边的数据大于该数据
第一次实现 : 让数据50作为基准值, 进行一次分组, 比50小的放左边, 比50大的放右边
第二次实现 : 继续分组
        对50左边的数据再次分组, 以30为基准, 把比30小的放左边, 比30大的放右边
        对50右边的数据再次分组, 以90为基准, 把比90小的放左边, 比90大的放右边
第三次分组 :
    ....
以此类推, 对30的左边和右边分组, 对90的左边和右边分组, 直到剩余最后一个或者没有, 无需分组,
    直到数列无需分组, 数列必然有序

以50为基准 :   0 10 30 40 20 [50] 100 60 70 90 80
以30,90位基准 :  0 10 20 [30] 40  [50]  60 80 70 [90] 100
以10, 70为基准 : 0 [10] 20 [30] 40  [50]  60 [70] 80 [90] 100

基准值 - 任意定

通过三个游标来实现
原地快排
    定义三个游标 - 三个变量 - 数据的下标
    p - pivot - 基准值, 基准值的下标为p

    int p = 5;
    int i = 0;//左边界
    int j = size-1;//右边界
    int pivot  = data[p];//将基准值备份到pivot变量中

    0 1  2  3  4  5  6  7  8  9  10     下标
    0 10 80 30 60 50 40 70 20 90 100
         i
                  p
                                  j

当i < p, data[i] < pivot, i++
    什么时候不i++, i>p || data[i]>pivot
    将data[i]的值移动到pivot的右边
    data[p] = data[i];
    p = i;
    0 1  2  3  4  5  6  7  8  9  10     下标
    0 10 80 30 60 80 40 70 20 90 100
         i
         p
                                  j

当j>p, data[j]>pivot, j--
    什么时候不j--, j<p || data[j]<pivot
    将data[j]放到pivot左边
    data[p] = data[j];
    p = j;

    0 1  2  3  4  5  6  7  8  9  10     下标
    0 10 20 30 60 80 40 70 20 90 100
         i
                           p
                           j

当i < p, data[i] < pivot, i++
    什么时候不i++, i>p || data[i]>pivot
    将data[i]的值移动到pivot的右边
    data[p] = data[i];
    p = i;
    0 1  2  3  4  5  6  7  8  9  10     下标
    0 10 20 30 60 80 40 70 60 90 100
               i
               p
                           j

当j>p, data[j]>pivot, j--
    什么时候不j--, j<p || data[j]<pivot
    将data[j]放到pivot左边
    data[p] = data[j];
    p = j;
    0 1  2  3  4  5  6  7  8  9  10     下标
    0 10 20 30 40 80 40 70 60 90 100
               i
                     p
                     j

当i < p, data[i] < pivot, i++
    什么时候不i++, i>p || data[i]>pivot
    将data[i]的值移动到pivot的右边
    data[p] = data[i];
    p = i;
    0 1  2  3  4  5  6  7  8  9  10     下标
    0 10 20 30 40 80 80 70 60 90 100
                  i
                  p
                     j

当j>p, data[j]>pivot, j--
    什么时候不j--, j<p || data[j]<pivot
    将data[j]放到pivot左边
    data[p] = data[j];
    p = j;
    0 1  2  3  4  5  6  7  8  9  10     下标
    0 10 20 30 40 80 80 70 60 90 100
                  i
                  p
                  j

i变化 - j变化 - i变化 - ...
    直到i == p == j  - 就是基准值应该在的位置
    data[p] = pivot;
    0 1  2  3  4  5  6  7  8  9  10     下标
    0 10 20 30 40 50 80 70 60 90 100
                  i
                  p
                  j
再次比较:
    0 1  2  3  4  5  6  7  8  9  10     下标
    0 10 20 30 40 50 80 70 60 90 100
    0          4  i  6           10
                  p
    left          j              right
    p - left > 1 -> 基准值左边的数据大于1个 -> 继续排序
    right - p > 1 -> 基准值右边的数据大于1个 -> 继续排序



    0 1  2  3  4  5  6  7  8  9  10     下标
    0 10 80 30 60 70 40 50 20 90 100
    基准值 : 50
    下标 : 7

    下标 : 5

二.查找算法
mv sort find
cd find
find.h
find.c
1.线性查找算法
    在数列中挨个匹配想要查找到的数据, 对数据的有序性没有要求
2.二分查找法
    折半查找 - 递归函数
前提 : 数据有序
原理:
    10 20 30 40 50 60 70 80//目标查找:60
    0  1  2  3  4  5  6  7
    int mid = (0 + 7)/2 = 3
    让数列对半分 拿着目标值和中间值比
    相等 - 返回对应下标
    目标值 > 中间值 - 右侧继续二分查找
    目标值 < 中间值 - 左侧继续二分查找

    10   20  30    40    50  60 70 80
    0     1   2    3     4   5  6  7
    left    mid-1  mid mid+1       right



语法 :
    纯C 不够
    使用c语言做项目 -
        和其他的知识点结合起来
            C + Unix - 银行开发
            C + keil + stm32 - 裸板
            C + arm  + Linux - 物联网/嵌入式 系统驱动
            C + C++ + Qt - 界面 - wps
            C + C++ + Qt + 硬件 -

    指针 数据类型
            

C语言书籍：c primer plus
