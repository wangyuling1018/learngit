今日内容:
一.高级指针
1.数组指针
    指针数组
    数组指针 - 指针 - 指向整个数组

    int arr[3] = {1,2,3};
    int* parr = arr;
    parr == arr;
    parr + 1 == (arr + 1) == 下标为1元素的地址
    parr + 1 * 4 = parr + 4

    int (*arr_p)[3] = &arr;
        arr地址上就有一个数组 - 数组有3个int类型的元素
        arr_p + 1 = arr_p + 1 * sizeof(arr) = arr_p + 12
    
    类似于这样的使用技巧适用于二维数组
double_arr.c

    普通指针

%-2d -
    2 - 宽度为2
    - - 左对齐
printf函数使用方式 - 百度

2.二级指针 与 多级指针
一级指针 -
    定义了指针变量, 存储了一个地址 - 该地址上存储了一个普通变量 - 一级指针

只要定义了变量 - 内存中必然是有地址的 - 适用于指针变量 - 指针变量也有地址

二级指针 -
    定义了指针变量, 存储了一个地址 - 该地址上存储了一个指针变量 - 二级指针

访问 -
    读
    写
//s1 = pa, s2 = pb;
void swap(char* s1, char* s2){
    char* tmp = NULL;
    tmp = s1;
    s1 = s2;
    s2 = tmp;
}


练习 :
swap.c
    void swap(char** ps1, char** ps2){
        
    }
main:
    char* pa = "hello";
    char* pb = "world";

    swap(&pa, &pb);

    char* pb = "hello";
    char* pa = "world";

------------------
二级指针 - 字符指针数组

char* arr[] = {"hello", "world"};
实际上存储的是char* 指针变量 - 每个指针变量指向字符串


char* p1 = "hello";
char* p2 = "world";
char* arr[] = {p1, p2};

明确:
    1. 数组中每个元素都是char* 类型的指针
    2. arr是数组中第0的元素的地址 arr具有二级指针的意思
        arr是一个地址
        在arr这个地址上存储的还是一个地址
    3. 可以定义二级指针变量来保存字符指针数组的首地址.
        char** parr = arr;
        parr 和 arr具有通用性
        不可以使用parr计算数组元素个数

ppstring.c

main函数:
    int main(int argc, char* argv[]){...}
    ==
    int main(int argc, char** argv){...}

结合性 - 变量名和谁先结合
int (*p1)[4];  - 数组指针 - 指针 - p1是指针，指向数组，数组中有4个int元素。
int* p2[4];    - 指针数组 - 数组 - p2是数组，数组中有4个int*元素
int (*p3)(int x, int y); - 函数指针 - 指针 - p3指向int ()(int,int)类型的函数
int* p4(int x, int y);  - 函数 - p4是函数，函数的返回值是int*，参数是2个int

掌握12字规则（从右到左，由近及远，括号优先）
int* p;   - p左是*，p是指针，啥类型指针？再左是int，是int类型的指针 - p是int类型指针
int* p[3]; - p右边是[],p是数组，里面有3个元素，啥类型元素？左边是*，是3个指针？啥类型指针？再左是int，是int类型指针 - p是一个数组，里面有3个int类型指针。  //指针数组
int* p[3][4]; - p右是[][],p是二维数组，每个元素啥类型？左是*，每个元素是指针，啥类型指针？再左是int，每个元素是int类型指针 - p是二位数组，里面有3*4个int类型指针   //指针二维数组
int(*p)[3]; - p左是*，p是指针，括号优先，p是指针，啥类型指针？再右是[],是指向3个元素的数组类型的指针，数组元素啥类型？再左是int，每个数组元素是int类型 - p是指针，指向数组，数组里面有3个int类型元素   //数组指针
int(*p[3])[4]; - p左是[],p是数组，数组中每个元素啥类型？右是*，数组每个元素是指针，啥类型指针？右是[4],指向4个元素的数组指针，每个元素啥类型？再左int，每个元素是int - p是数组，里面有3个指针类型元素，每个指针指向有4个int元素的数组。   //数组指针 数组
int(*f)(int,double); - p左是*，p是指针，啥类型指针？右是（），指向函数类型的指针，再zuo是int函数的返回值是int - f是指向函数的指针，该函数的参数是（int，double），返回值是int      //函数指针
int(*f[3])(int,double); - p右是[3],p是3个元素的数组，啥元素类型的数组？左是*，3个指针类型元素，指针指向啥？右是（），指针指向函数，函数的返回值是啥？再左int，返回值是int - p是数组，里面有3个地址（指针），每个元素存的函数的地址。             //函数指针 数组


从最底层角度理解指针 - 指针就是地址(最大的普遍性)
普遍性的基础上 - 特殊性
    函数指针 - 存储函数的地址 - 特点 - 使用场景 - 注意事项
    数组指针 - 指向一个数组 - 特点 - 使用场景 - 注意
    二级指针 - 存储指针变量的地址 - 特点 - 使用场景 - 注意
    



内存分布图:
---------------------
栈区    定义局部变量
    int var = 100;
    char* str = hello字符串首地址;
---------------------
堆区    - 动态内存分配
---------------------
全局区  全局变量 / 静态变量
        int g_val = 100;
        static int var = 100;
---------------------
常量区  - 字符串字面值
            "hello"
---------------------
代码区 -  函数
---------------------

二.动态内存分配
    C语言分配内存的第四种方法

    变量 - 数组 - 结构体 - 动态内存分配

    一次性分配大量内存 - 数据类型不一致
    struct stu{
        char a;
        int b;
        char c;
        short d;
        float f;
        ...
    }

动态内存分配缺点 :
    只能在堆区

1.动态内存分配
    malloc - memory alloc - 内存分配
    void* malloc(size_t size);
    
    返回值 - void* - 泛型指针 - 可以转换任意类型 - 分配的这块内存 - 可以存储任意类型数据

生命周期 - 这块内存空间何时消亡
    1.调用free函数后 - 该内存会被释放
    2.程序结束
问题 : 如果忘记使用free函数释放该空间, 且程序一直运行 - 后果 - 这块内存一直被占用
    其他程序 - 完全无法使用

2.动态内存释放
    void free(void* ptr);
    释放ptr指向的内存空间 - 就是malloc函数的返回值

malloc.c
---------------------
三.文件操作


